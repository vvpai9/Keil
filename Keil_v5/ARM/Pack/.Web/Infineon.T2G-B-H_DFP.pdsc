<?xml version="1.0" encoding="UTF-8"?>
<package schemaVersion="1.7.44" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="https://raw.githubusercontent.com/Open-CMSIS-Pack/Open-CMSIS-Pack-Spec/v1.7.44/schema/PACK.xsd">
  <vendor>Infineon</vendor>
  <name>T2G-B-H_DFP</name>
  <description overview="Overview.md">Infineon Traveo T2G Body High Device Family Pack</description>
  <url>https://itools.infineon.com/cmsis_packs/T2G-B-H/</url>
  <license>APACHE_LICENSE.txt</license>
  <licenseSets>
    <licenseSet id="all" default="true" gating="true">
      <license name="./APACHE_LICENSE.txt" title="Apache 2.0 License" spdx="Apache-2.0"/>
    </licenseSet>
  </licenseSets>

  
  <releases>
     <release version="1.2.1" date="2025-09-19">
      - Updated the License set
      - Added Overview.md file
    </release>
    <release version="1.2.0" date="2025-07-07">
      - Updated the Schema version to 1.7.44      
      - Updated the License set
      - Removed "Debug/cat1c.sdf" file
      Added the following drivers
      - cy_cordic.c
      - cy_crypto_core_ecc_ec25519.c
      - cy_crypto_core_ecc_eddsa.c
      - cy_hppass.c
      - cy_hppass_ac.c
      - cy_hppass_csg.c
      - cy_hppass_sar.c
      - cy_mpc.c
      - cy_ms_ctl.c
      - cy_ppc.c
      - cy_tcpwm_motif.c
    </release>
    <release version="1.1.0" date="2025-02-22">
      Added patch to generate cycfg_peripherals.c all the time
      Update the following libraries:
      - core-lib release-v1.4.3
      - mtb-pdl-cat1 release-v3.14.0
      - mtb-template-cat1 release-v1.7.1
      - device-db release-v4.21.0
    </release>
    <release version="1.0.0" date="2024-09-20">
      Initial Version
    </release>
  </releases>

  <keywords>
    <!-- keywords for indexing -->
    <keyword>Infineon</keyword>
    <keyword>Device Support</keyword>
    <keyword>Traveo2</keyword>
    <keyword>T2G-B-H</keyword>
  </keywords>

  <requirements>
    <languages>
      <language name="C" version="99"/>
    </languages>
  </requirements>

  <devices>
  <family Dfamily="T2G-B-H" Dvendor="Infineon:7">
    <book name="https://developer.arm.com/documentation/dui0662/latest" title="Cortex-M0+ Generic User Guide"/>
    <feature type="Temp" n="-40" m="125" name="Extended Operating Temperature Range"/>
    <feature type="VCC" n="2.7" m="5.5"/>
    <feature type="MemoryOther" n="4160" name="KB Code Flash"/> 
    <feature type="MemoryOther" n="8384" name="KB Code Flash"/>
    <!-- CYT3BB: 4160KB Flash, Dual-Core -->
    <subFamily DsubFamily="CYT3BB">
      <processor Pname="Cortex-M0p" Dcore="Cortex-M0+" DcoreVersion="r0p1" Dfpu="NO_FPU" Dmpu="MPU" Dendian="Little-endian" Dclock="50000000" />
      <processor Pname="Cortex-M7-0" Dcore="Cortex-M7" DcoreVersion="r1p2" Dfpu="SP_FPU" Dmpu="MPU" Dendian="Little-endian" Dclock="250000000" />
      <debugconfig default="swd" clock="2000000" sdf="Debug/cat1c.sdf" />
      <description>
        CYT3BB: Dual-core Cortex-M7/M0+ MCU series with programmable digital and analog peripherals.
      </description>
      <debug Pname="Cortex-M7-0" svd="Libraries/mtb-pdl-cat1/devices/COMPONENT_CAT1C/svd/cat1c4m.svd" __ap="2" defaultResetSequence="ResetSystem" />
      <debug Pname="Cortex-M0p" svd="Libraries/mtb-pdl-cat1/devices/COMPONENT_CAT1C/svd/cat1c4m.svd" __ap="1" defaultResetSequence="ResetProcessor" />
      <memory name="IRAM1" access="rwx" start="0x28000000" size="0xC0000" default="1" />
      <memory name="IROM1" access="rx" start="0x10000000" size="0x410000" default="1" startup="1" />
      <algorithm Pname="Cortex-M0p" name="Flash/CAT1C_4160.FLM" start="0x10000000" size="0x00410000" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M0p" name="Flash/CAT1C_WFLASH_256.FLM" start="0x14000000" size="0x00040000" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M0p" name="Flash/CAT1C_SFLASH_USER.FLM" start="0x17000800" size="0x00000800" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M0p" name="Flash/CAT1C_SFLASH_NAR.FLM" start="0x17001A00" size="0x00000200" RAMstart="0x28001000" RAMsize="0xFFF0" default="0" style="Keil" />
      <algorithm Pname="Cortex-M0p" name="Flash/CAT1C_SFLASH_PKEY.FLM" start="0x17006400" size="0x00000C00" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M0p" name="Flash/CAT1C_SFLASH_TOC2.FLM" start="0x17007C00" size="0x00000200" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M0p" name="Flash/CAT1C_SMIF.FLM" start="0x60000000" size="0x08000000" RAMstart="0x28001000" RAMsize="0xFFF0" default="0" style="Keil" />
      <algorithm Pname="Cortex-M7-0" name="Flash/CAT1C_4160.FLM" start="0x10000000" size="0x00410000" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M7-0" name="Flash/CAT1C_WFLASH_256.FLM" start="0x14000000" size="0x00040000" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M7-0" name="Flash/CAT1C_SFLASH_USER.FLM" start="0x17000800" size="0x00000800" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M7-0" name="Flash/CAT1C_SFLASH_NAR.FLM" start="0x17001A00" size="0x00000200" RAMstart="0x28001000" RAMsize="0xFFF0" default="0" style="Keil" />
      <algorithm Pname="Cortex-M7-0" name="Flash/CAT1C_SFLASH_PKEY.FLM" start="0x17006400" size="0x00000C00" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M7-0" name="Flash/CAT1C_SFLASH_TOC2.FLM" start="0x17007C00" size="0x00000200" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M7-0" name="Flash/CAT1C_SMIF.FLM" start="0x60000000" size="0x08000000" RAMstart="0x28001000" RAMsize="0xFFF0" default="0" style="Keil" />
      <book name="https://www.infineon.com/dgdl/Infineon-TRAVEO_T2G_automotive_microcontroller_CYT3BB_4BB_32-BIT_ARM_CORTEX-M7-DataSheet-v11_00-EN.pdf?fileId=5546d4627883d7e00178a73ba6ad1732" title="TRAVEO™ T2G CYT3BB/CYT4BB Series Data Sheet"/>
      <book name="https://www.infineon.com/sec/login?ret=https%3A%2F%2Fwww.infineon.com%2Fcms%2Fen%2Fproduct%2Fmicrocontroller%2F32-bit-traveo-t2g-arm-cortex-microcontroller%2F32-bit-traveo-t2g-arm-cortex-for-body%2Ftraveo-t2g-cyt3bb-cyt4bb-series%2F%23!documents%2Fdocument-group-myInfineon-57" title="TRAVEO™ T2G CYT3BB/CYT4BB TRM"/>
      <book name="https://www.infineon.com/cms/en/product/microcontroller/32-bit-traveo-t2g-arm-cortex-microcontroller/32-bit-traveo-t2g-arm-cortex-for-body/traveo-t2g-cyt3bb-cyt4bb-series/" title="Overview of TRAVEO™ T2G CYT3BB/CYT4BB Series"/>
      <debugvars configfile="Debug/cat1c.dbgconf" version="1.0">
        __var __TPIU_pinlocation = 1;                      // Select one of the possible TPIU pin locations
        __var __TPIU_clocksetup = 1;                       // Enable(1) or Disable(0) setup of trace source clock
        __var __TPIU_clockdivval = 0;                      // Clock divider value for trace clock
        // TraceClock configuration data
        __var TRACE_CLOCK_CTL_ADDR = 0x40040C00;           // Clock control register for cpuss.clock_trace_in
        __var TRACE_CLOCK_DIV_CTL_ADDR = 0x40041020;       // Divider control (for 8.0 divider)
        __var TRACE_CLOCK_DIV_CMD_ADDR = 0x40040000;       // Divider command
        __var PERI_CLOCK_CTL_DIV_SEL = 0x02;               // CYT3BB devices have 3 of 8-bit dividers - use the lastest available for tracing
        __var PERI_DIV_PA_SEL_MASK = 0x000003FF;           // PA_TYPE_SEL + PA_DIV_SEL fields mask (size)
        __var PERI_DIV_CMD_PA_SEL_ROL = 0x00000010;        // PA_TYPE_SEL + PA_DIV_SEL fields offset in PERI_DIV_CMD
        // TPIU pins configuration data
        __var hsiomPrt21PortSel0Addr = 0x40300150;  // HSIOM_PRT[port]_PORT_SEL0·register·address. Port 21 selection 0
        __var hsiomPrt22PortSel0Addr = 0x40300160;  // HSIOM_PRT[port]_PORT_SEL0·register·address. Port 22 selection 0
        __var gpioPrt21CfgAddr = 0x40310AC4;        // GPIO_PRT[port]_CFG register address. Port 21 configuration
        __var gpioPrt22CfgAddr = 0x40310B44;        // GPIO_PRT[port]_CFG register address. Port 22 configuration
        __var gpioPrt21CfgOutAddr = 0x40310ACC;     // GPIO_PRT[port]_CFG_OUT register address. Port 21 output buffer configuration
        __var gpioPrt22CfgOutAddr = 0x40310B4C;     // GPIO_PRT[port]_CFG_OUT register address. Port 22 output buffer configuration
      </debugvars>
      <sequences>
        <sequence name="DebugPortStart">
          <block info="Read DP CTRL/STAT">
            __var SW_DP_ABORT  = 0x0;
            __var DP_CTRL_STAT = 0x4;
            __var DP_SELECT    = 0x8;
            __var powered_down = 0;
            // Switch to DP Register Bank 0. Explicitly set APSEL to current AP selection
            WriteDP(DP_SELECT, __ap &lt;&lt; 24);
            // Read DP CTRL/STAT Register and check if CSYSPWRUPACK and CDBGPWRUPACK bits are set
            powered_down = ((ReadDP(DP_CTRL_STAT) &amp; 0xA0000000) != 0xA0000000);
          </block>
          <control if="powered_down">
            <block info="Power Up System &amp; Debug">
              // Request Debug/System Power-Up
              // Ignore error here: even there is a polling in the next block, CMSIS-DAP transports reads DP.RDBUFF register
              // right after write to DP.CTRL_STAT. This will fail for some cases - for example if device is waking from DeepSleep.
              __errorcontrol = 1;
              WriteDP(DP_CTRL_STAT, 0x50000000);
              __errorcontrol = 0;
            </block>
            <!-- Wait for Power-Up Request to be acknowledged -->
            <control while="(ReadDP(DP_CTRL_STAT) &amp; 0xA0000000) != 0xA0000000" timeout="1000000" info="Wait for power acknowledged" />
            <!-- CDBGRSTREQ on CAT1C behaves like Power-On Reset. Not desired when starting the Debug Port
            <block info="Debug Reset">
              __errorcontrol = 1;
              // Request Debug Reset
              WriteDP(DP_CTRL_STAT, 0x54000000);
              // CDBGRSTREQ is equivalent to Power-On Reset and fully reboots the device.
              // Depending on the user application the reboot can take up to 600ms.
              DAP_Delay(600000);
              __errorcontrol = 0;
            </block>
            -->
            <!-- Wait for Debug Reset to be acknowledged, don't issue error on timeout to deal with improperly connected Debug Reset -->
            <!-- <control while="(ReadDP(DP_CTRL_STAT) &amp; 0xA8000000) != 0xA8000000" timeout="300000" info="Wait for Debug Reset Acknowledge"/> -->
            <!-- JTAG Specific Part of sequence -->
            <control if="(__protocol &amp; 0xFFFF) == 1">
              <block info="JTAG: Clear Sticky Bits">
                // Init AP Transfer Mode, Transaction Counter, and Lane Mask (Normal Transfer Mode, Include all Byte Lanes)
                // Additionally clear STICKYORUN, STICKYCMP, and STICKYERR bits by writing '1'
                WriteDP(DP_CTRL_STAT, 0x50000F32);
              </block>
            </control>
            <!-- SWD Specific Part of sequence -->
            <control if="(__protocol &amp; 0xFFFF) == 2">
              <block info="SWD: Init SWD &amp; Clear Sticky Bits">
                // Init AP Transfer Mode, Transaction Counter, and Lane Mask (Normal Transfer Mode, Include all Byte Lanes)
                WriteDP(DP_CTRL_STAT, 0x50000F00);
                // Clear WDATAERR, STICKYORUN, STICKYCMP, and STICKYERR bits of CTRL/STAT Register by write to ABORT register
                WriteDP(SW_DP_ABORT, 0x0000001E);
              </block>
            </control>
          </control>
          <control if="(__connection &amp; 3) == 2">
            <block>
              // Prepare MCU for flash operations
              Sequence("FlashPreparation");
            </block>
          </control>
          <control if="(__connection &amp; 3) == 1">
            <block>
              // Checking core readiness for debugging
              Sequence("DebuggingReadiness");
            </block>
          </control>
          <block>
            // Print device info
            Sequence("PrintDeviceInfo");
          </block>
        </sequence>
        <!-- HW Reset causes a reboot of the device which also resets debug.
             - Using this as a prereset is OK to potentially wake up the system from DeepSleep.
             - Using this in the middle of the debug session will break the connection unless recovery
               from a connection loss is supported by the debug IDE.
        -->
        <sequence name="ResetHardware">
          <block>
            __var nReset      = 0x80;
            __var canReadPins = 0;
            // Deassert nRESET line
            canReadPins = (DAP_SWJ_Pins(0x00, nReset, 0) != 0xFFFFFFFF);
          </block>
          <!-- Keep reset active for 50 ms -->
          <control while="1" timeout="50000" />
          <control if="canReadPins">
            <!-- Assert nRESET line and wait max. 1s for recovery -->
            <control while="(DAP_SWJ_Pins(nReset, nReset, 0) &amp; nReset) == 0" timeout="1000000" />
          </control>
          <control if="!canReadPins">
            <block>
              // Assert nRESET line
              DAP_SWJ_Pins(nReset, nReset, 0);
            </block>
            <!-- Wait 100ms for recovery if nRESET not readable -->
            <control while="1" timeout="100000" />
          </control>
          <block>
            // Give the bootloader time to finish (can be up to 600ms)
            DAP_Delay(600000);
          </block>
        </sequence>
        <sequence name="ResetSystem" Pname="Cortex-M0p">
          <block info="Halt CPU and determine application entry point">
            // System Control Space (SCS) offset as defined in Armv6-M/Armv7-M.
            __var SCS_Addr = 0xE000E000;
            __var AIRCR_Addr = SCS_Addr + 0xD0C;
            __var DHCSR_Addr = SCS_Addr + 0xDF0;
            __var BP_CTRL = 0xE0002000;
            __var BP_COMPx = 0xE0002008;
            __var DP_CTRL_STAT = 0x4;
            __var appValid = 0;
            __var vtBase = 0;
            __var resetAddress = 0;

            // Read VT_BASE register
            vtBase = Read32(0x40201120) &amp; 0xFFFF0000;
            appValid = (vtBase != 0) &amp;&amp; (vtBase != 0xFFFF0000);
          </block>
          <control if="appValid">
            <block info="Set BP at app entry and issue a reset">
              //Get application address at reset vector
              resetAddress = Read32(vtBase + 4);
            </block>
            <control if="(resetAddress != 0) &amp;&amp; (resetAddress != 0xFFFFFFFF)">
              <block>
                // Enable debug, and halt the CPU
                Write32(DHCSR_Addr, 0xA05F0003);

                // Enable Breakpoint unit using the BP_CTRL
                Write32(0xE0002000, 0x00000003);

                // Map the address bits to the breakpoint compare register
                resetAddress = (resetAddress &amp; 0x1FFFFFFC) | 0xC0000001;

                // Update the breakpoint compare register
                Write32(0xE0002008, resetAddress);

                // Issue software reset using the AIRCR (Application Interrupt and Reset
                // Control Register). Note: do not check for ACK_OK of this operation
                __errorcontrol = 1;
                Write32(AIRCR_Addr, 0x05FA0004);
                sequence("DAP_poll");
                __errorcontrol = 0;
              </block>
              <!-- Reset Recovery: Wait for CPUSS_CM0_CTL to  bit to clear on read -->
              <control while="(Read32(DHCSR_Addr) &amp; 0x02000000)" timeout="500000" />
              <block>
                // Enable CM7 core(s) in order to be able to attach to it
                Sequence("DebuggingReadiness");
              </block>
            </control>
          </control>
        </sequence>
        <!-- Cortex-M0+ Processor reset via XMC7xxx CPU Sub-System Controller. Cortex-M0+ doesn't have VECTRESET. -->
        <sequence name="ResetProcessor" Pname="Cortex-M0p">
          <block>
            __var CPUSS_CM0_CTL_Addr = 0x40201000;    // CM0+ Control Register
            __var DHCSR_Addr = 0xE000EDF0;
            Write32(CPUSS_CM0_CTL_Addr, 0x05FA0000);  // Reset CM0+
          </block>
          <!-- Reset Recovery: Wait for CPUSS_CM0_CTL to  bit to clear on read -->
          <control while="(Read32(DHCSR_Addr) &amp; 0x02000000)" timeout="500000" />
        </sequence>
        <!-- Prepare CM0+ core to serve SROM API calls -->
        <sequence name="PrepareCM0">
          <block>
            __var WFI_LOOP_ADDR = 0x28000000 + 0x800;
            __var CM0_SP_ADDR = WFI_LOOP_ADDR + 0x40;
            // Halt CM0+
              Write32(0xE000EDF0, 0xA05F0003);
          </block>
          <control while="(Read32(0xE000EDF0) &amp; 0x00030000) != 0x00030000" timeout="1000000" info="Wait for core halts" />
          <block>
            // Write WFI loop in RAM
            Write32(WFI_LOOP_ADDR, 0xE7FDBF30);
            // Set VECTCLRACTIVE in AIRCR for CM0+
            Write32(0xE000ED0C, 0x05FA0002);
            // Write CM0+ xPSR
            Write32(0xE000EDF8, 0x01000000);
            Write32(0xE000EDF4, 0x00010010);
          </block>
          <control while="(Read32(0xE000EDF0) &amp; 0x00010000) != 0x00010000" timeout="1000000" info="Wait for register transfer to complete" />
          <block>
            // Write CM0+ CONTROL, PRIMASK
            Write32(0xE000EDF8, 0x00000000);
            Write32(0xE000EDF4, 0x00010014);
          </block>
          <control while="(Read32(0xE000EDF0) &amp; 0x00010000) != 0x00010000" timeout="1000000" info="Wait for register transfer to complete" />
          <block>
            // Write CM0+ PC
            Write32(0xE000EDF8, WFI_LOOP_ADDR);
            Write32(0xE000EDF4, 0x0001000F);
          </block>
          <control while="(Read32(0xE000EDF0) &amp; 0x00010000) != 0x00010000" timeout="1000000" info="Wait for register transfer to complete" />
          <block>
            // Write CM0+ SP
            Write32(0xE000EDF8, CM0_SP_ADDR);
            Write32(0xE000EDF4, 0x0001000D);
          </block>
          <control while="(Read32(0xE000EDF0) &amp; 0x00010000) != 0x00010000" timeout="1000000" info="Wait for register transfer to complete" />
          <block>
            // Write CM0+ VTOR
            Write32(0xE000ED08, 0x00000000);
            // Clear all pending interrupts in CM0+
            Write32(0xE000E280, 0x0000FFFF);
            // Enable only CM0+ IRQ0/1
            Write32(0xE000E180, 0xFFFFFFFC);
            Write32(0xE000E100, 0x00000003);
            // Set priority of IRQ0=1, IRQ1=0. Need to make sure IRQ1 is triggered even if IRQ0 is pending.
            Write32(0xE000E400, 0x00000040);
            // Release CM0+ from halt state
            Write32(0xE000EDF0, 0xA05F0001);
          </block>
        </sequence>
        <sequence name="DAP_Handshake">
          <!-- DAP_Handshake: Execute initial handshake sequence depend on selected protocol -->
          <block>
            __var isSWJ      = ((__protocol &amp; 0x00010000) != 0);
            __var protType   = __protocol &amp; 0x0000FFFF;
            __var DPIDR = 0;
            __Result = 0;
          </block>
          <!-- JTAG Protocol -->
          <control if="protType == 1">
            <control if="isSWJ">
              <block atomic="true">
                // Ensure current debug interface is in reset state
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF);
                // Execute SWJ-DP Switch Sequence SWD to JTAG (0xE73C)
                // Change if SWJ-DP uses deprecated switch code (0xAEAE)
                DAP_SWJ_Sequence(16, 0xE73C);
              </block>
            </control>
            <block atomic="true">
              // JTAG "Soft" Reset
              DAP_JTAG_Sequence(6, 1, 0x00);                        // Test-Logic-Reset
              // Get IDCODE to make shure that JTAG-DP is available
              DAP_JTAG_Sequence(4, 0, 0x00);                        // 4*Run-Test/Idle
              DAP_JTAG_Sequence(2, 1, 0x00);                        // ~ Select-DR ~ Select-IR
              DAP_JTAG_Sequence(2, 0, 0x00);                        // ~ Capture-IR ~ Shift-IR
              DAP_JTAG_Sequence(8, 0, 0xFE);                        // Shift-IR (IDCODE BYPASS)
              DAP_JTAG_Sequence(5, 1, 0x00);                        // ~ Exit1-IR (IDCODE BYPASS) ~ Update-IR ~ Test-Logic-Reset
              DAP_JTAG_Sequence(4, 0, 0x00);                        // Make sure that we go through Idle state in TAP controller
              DAP_JTAG_Sequence(1, 1, 0x00);                        // Select-DR
              DAP_JTAG_Sequence(2, 0, 0x00);                        // ~ Capture-DR ~ Shift-DR
              DPIDR = DAP_JTAG_Sequence(33, 0, 0x00000000);         // Shift 33-bits data
              DAP_JTAG_Sequence(5, 1, 0x00);                        // ~ Exit1-DR ~ Update-DR ~ ~ Select-DR ~ Select-IR ~ Test-Logic-Reset
              DAP_JTAG_Sequence(4, 0, 0x00);                        // Make sure that we go through Idle state in TAP controller
            </block>
          </control>
          <!-- SWD Protocol -->
          <control if="protType == 2">
            <control if="isSWJ">
              <block atomic="true">
                // Ensure current debug interface is in reset state
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF);
                // Execute SWJ-DP Switch Sequence JTAG to SWD (0xE79E)
                // Change if SWJ-DP uses deprecated switch code (0xEDB6)
                DAP_SWJ_Sequence(16, 0xE79E);
                // Enter SWD Line Reset State
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // More than 50 cycles SWDIO/TMS High
                DAP_SWJ_Sequence(3,  0x00);               // At least 2 idle cycles (SWDIO/TMS Low)
              </block>
            </control>
            <control if="!isSWJ">
              <block atomic="true">
                // Enter SWD Line Reset State
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // More than 50 cycles SWDIO/TMS High
                DAP_SWJ_Sequence(3,  0x00);               // At least 2 idle cycles (SWDIO/TMS Low)
              </block>
            </control>
            <block>
              DPIDR = ReadDP(0x0); // Read DPIDR to enable SWD interface (SW-DPv1 and SW-DPv2)
            </block>
          </control>
          <control if="(DPIDR &amp; 0xFFF00FFF) != 0x6BA00477">
            <block>
              __Result = -1; // DAP is unavailable
            </block>
          </control>
        </sequence>
        <sequence name="DAP_poll">
          <!-- DAP_poll: Poll the DAP until it becomes available -->
          <block>
            __Result = -1; // Assume DAP is not available yet
          </block>
          <control while="__Result != 0" timeout="600000">
            <block>
              sequence("DAP_Handshake"); // Poll DP until bootloader allows access to device (can be up to 600ms)
            </block>
          </control>
          <control if="__Result != 0">
            <block>
              Message(1, "The Debug Access Port is unavailable.");
            </block>
          </control>
        </sequence>
        <!-- Enable CM7 clock -->
        <sequence name="EnableCM7Clock">
          <block>
            __var CLK_ROOT_SELECT = Read32(0x40261244);
          </block>
          <control if="(CLK_ROOT_SELECT &amp; 0x80000000) != 0x80000000">
            <block>
              Write32(0x40261244, (CLK_ROOT_SELECT | 0x80000000));
              Message(0, "CLK_HF1 was enabled.");
            </block>
          </control>
        </sequence>
        <!-- Set power mode of CM7_0 core to ENABLED -->
        <sequence name="PowerUpCM7_0">
          <block>
            __var CM7_PWR_CTL_ADDR = 0x40201200;
            __var CM7_PWR_CTL = Read32(CM7_PWR_CTL_ADDR);
          </block>
          <control if="(CM7_PWR_CTL &amp; 0x3) != 0x3">
            <block>
              // Set power mode of CM7
              Write32(CM7_PWR_CTL_ADDR, 0x05FA0003);
              Message(0, "The power mode of Cortex-M7_0 core was set to ENABLED.");
            </block>
          </control>
          <!-- Set power mode of CM7 to ENABLED. The core will stop at reset vector -->
          <block>
            __var CPUSS_CM7_CTL_ADDR = 0x4020000C;
            __var CPUSS_CM7_CTL = Read32(CPUSS_CM7_CTL_ADDR);
          </block>
          <control if="CPUSS_CM7_CTL &amp; 0x10">
            <block>
              // Deassert CPU_WAIT
              Write32(CPUSS_CM7_CTL_ADDR, (CPUSS_CM7_CTL &amp; 0xFFFFFFEF));
              Message(0, "CPU_WAIT of Cortex-M7_0 core was deasserted.");
            </block>
          </control>
        </sequence>
        <!-- Check CM7 clock -->
        <sequence name="CheckCM7Clock">
          <block>
            __var CLK_ROOT_SELECT = Read32(0x40261244);
          </block>
          <control if="(CLK_ROOT_SELECT &amp; 0x80000000) != 0x80000000">
            <block>
              Message(2, "The CM7 core clock source (CLK_HF1) is not enabled by the CM0+ application. Further debugging is not possible.");
            </block>
          </control>
        </sequence>
        <!-- Check power mode of CM7_0 core  -->
        <sequence name="CheckPowerCM7_0">
          <block>
            __var CM7_PWR_CTL_ADDR = 0x40201200;
            __var CM7_PWR_CTL = Read32(CM7_PWR_CTL_ADDR);
          </block>
          <control if="(CM7_PWR_CTL &amp; 0x3) != 0x3">
            <block>
              Message(2, "The power mode of Cortex-M7_0 core was NOT ENABLED by the CM0+ application. Further debugging is not possible.");
            </block>
          </control>
        </sequence>
        <!-- Read and print device info -->
        <sequence name="PrintDeviceInfo">
          <block>
            __var siId;
            __var siRev;
            __var siFamily;
            __var fbVerHi;
            __var protection;
            __var v;
            Message(0, "****************************************************");
            // Get Si Id, Family and Rev.
            v = Read32(0x17000000);
            siId = (v &amp; 0xFFFF0000) &gt;&gt; 16;
            siRev = (v &amp; 0x0000FF00) &gt;&gt; 8;
            v = Read32(0x1700000C);
            siFamily = v &amp; 0x00000FFF;
            Message(0, "** Silicon: 0x%04X, Family: 0x%03X, Rev.: 0x%02X", siId, siFamily, siRev);
            // Get FlashBboot verison
            fbVerHi = Read32(0x17002004);
          </block>
          <control if="fbVerHi == 0">
            <block>
              Message(1, "Invalid FlashBoot: High version word of Flash Boot is zero");
            </block>
          </control>
          <control if="fbVerHi != 0">
            <block>
              __var fbVerLo = Read32(0x17002018);
              __var b0 = fbVerHi &gt;&gt; 28;
              __var b1 = (fbVerHi &gt;&gt; 24) &amp; 0x0F;
              __var b2 = (fbVerHi &gt;&gt; 16) &amp; 0xFF;
              __var b3 = fbVerHi &amp; 0x0000FFFF;
            </block>
            <control if="b0 &gt; 2">
              <block>
                Message(1, "Unsupported Flash Boot Version - Flash Boot Version [31:28] = 0x%X", b0);
              </block>
            </control>
            <control if="b0 &lt;= 2">
              <control if="b3 != 0x8001">
                <block>
                  Message(1, "Flash Boot is corrupted or non Flash Boot image programmed");
                </block>
              </control>
              <control if="b3 == 0x8001">
                <!-- Versioning scheme #1 -->
                <control if="b0 == 0">
                  <control if="b1 == 1">
                    <block>
                      Message(0, "** Flash Boot version: 1.%02u", b2);
                    </block>
                  </control>
                  <control if="b1 == 2">
                    <control if="b2 &lt; 20">
                      <block>
                        Message(0, "** Flash Boot version: 1.0.0.%u", b2);
                      </block>
                    </control>
                    <control if="(b2 &gt;= 20) &amp;&amp; (b2 &lt; 29)">
                      <block>
                        Message(0, "** Flash Boot version: 1.0.1.%u", b2);
                      </block>
                    </control>
                    <control if="b2 &gt;= 29">
                      <block>
                        Message(0, "** Flash Boot version: 1.20.1.%u", b2);
                      </block>
                    </control>
                  </control>
                </control>
                <!-- Versioning scheme #2 -->
                <control if="b0 == 1">
                  <block>
                    Message(0, "** Flash Boot version: 2.0.0.%u", b2);
                  </block>
                </control>
                <!-- Versioning scheme #3 -->
                <control if="b0 == 2">
                  <block>
                    __var patch = fbVerLo &gt;&gt; 24;
                    __var build = fbVerLo &amp; 0x0000FFFF;
                    Message(0, "** Flash Boot version: %u.%u.%u.%u", b1, b2, patch, build);
                  </block>
                </control>
              </control>
            </control>
          </control>
          <!-- Get life-cycle stage -->
          <control>
            <block>
              protection = Read32(0x402020C4);
            </block>
          </control>
          <!-- Decode life-cycle stage -->
          <control if="protection == 1">
            <block>
              Message(0, "** Chip Protection: VIRGIN");
            </block>
          </control>
          <control if="protection == 2">
            <block>
              Message(0, "** Chip Protection: NORMAL");
            </block>
          </control>
          <control if="protection == 3">
            <block>
              Message(0, "** Chip Protection: SECURE");
            </block>
          </control>
          <control if="protection == 4">
            <block>
              Message(0, "** Chip Protection: DEAD");
            </block>
          </control>
          <control if="(protection == 0) || (protection &gt; 4)">
            <block>
              Message(0, "** Chip Protection: UNKNOWN");
            </block>
          </control>
          <block>
            Message(0, "****************************************************");
          </block>
        </sequence>
        <sequence name="SetupTraceClock">
          <control if="__TPIU_clocksetup != 0">
            <block>
              __var PERI_CLOCK_CTL_DIV_SEL_MASK = 0x0000000F;                    // PERI_CLOCK_CTL.DIV_SEL
              __var PERI_DIV_CMD_ENABLE_MASK = 0x80000000;                       // ENABLE field in PERI_DIV_CMD
              __var PERI_DIV_CMD_DISABLE_MASK = 0x40000000;                      // DISABLE field in PERI_DIV_CMD
              // Peripheral clock divider index to use for trace clock
              __var ClockDivSel = PERI_CLOCK_CTL_DIV_SEL &amp; PERI_CLOCK_CTL_DIV_SEL_MASK;
              __var ClockDivVal = __TPIU_clockdivval &amp; PERI_DIV_PA_SEL_MASK; // Peripheral clock divider value for trace clock
                                                                                 // Actual divider is (1+ClockDivVal)
              __var ClockCtlVal = Read32(TRACE_CLOCK_CTL_ADDR);
              __var ClockDivCtlVal = Read32(TRACE_CLOCK_DIV_CTL_ADDR + (ClockDivSel * 4));
            </block>
            <control if="(ClockCtlVal != ClockDivSel) || (ClockDivCtlVal != ((ClockDivVal &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | 0x1))">
              <block>
                Message(0, "Setup TPIU clock, divider value is %u", ClockDivVal);
                // DISABLE 8.0 DIV in PERI_DIV_CMD:
                __var ClockDivCmd = PERI_DIV_CMD_DISABLE_MASK | (PERI_DIV_PA_SEL_MASK &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | ClockDivSel;
                Write32(TRACE_CLOCK_DIV_CMD_ADDR, ClockDivCmd);
                // Use selected divider (8.0) for cpuss.clock_trace_in
                Write32(TRACE_CLOCK_CTL_ADDR, ClockDivSel);
                // Set 8.0 DIV = ClockDivVal
                Write32((TRACE_CLOCK_DIV_CTL_ADDR + (ClockDivSel * 4)), (ClockDivVal &lt;&lt; 8));
                // ENABLE 8.0 DIV
                ClockDivCmd = PERI_DIV_CMD_ENABLE_MASK | (PERI_DIV_PA_SEL_MASK &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | ClockDivSel;
                Write32(TRACE_CLOCK_DIV_CMD_ADDR, ClockDivCmd);
              </block>
            </control>
          </control>
        </sequence>
        <!-- Configure pins trace pins if Parallel Trace Port enabled -->
        <sequence name="SetupTracePins">
          <control if="(__traceout &amp; 0x00000002) != 0" info="Parallel Trace Port enabled">
            <control if="__TPIU_pinlocation == 1" info="XMC72_EVK Kit like">
              <block>
                __var tpWidth = (__traceout &amp; 0x003F0000) &gt;&gt; 16;
                sequence("SetupTracePin_P22_4"); // TRACECLK
                sequence("SetupTracePin_P21_5"); // TRACEDATA[0]
              </block>
              <control if="tpWidth &gt; 1">
                <block>
                  sequence("SetupTracePin_P22_1"); // TRACEDATA[1]
                </block>
              </control>
              <control if="tpWidth &gt; 2">
                <block>
                  sequence("SetupTracePin_P22_2"); // TRACEDATA[2]
                  sequence("SetupTracePin_P22_3"); // TRACEDATA[3]
                </block>
              </control>
            </control>
          </control>
        </sequence>
        <!-- Setup Trace Pin 21_5 as TRACEDATA[0]  -->
        <sequence name="SetupTracePin_P21_5">
          <block>
            __var pin = 5;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P21_5)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt21PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt21PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt21CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt21CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt21CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt21CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[0] to P21_5");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P22_1 as TRACEDATA[1] -->
        <sequence name="SetupTracePin_P22_1">
          <block>
            __var pin = 1;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P22_1)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt22PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt22PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt22CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt22CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt22CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt22CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[1] to P22_1");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P22_2 as TRACEDATA[2] -->
        <sequence name="SetupTracePin_P22_2">
          <block>
            __var pin = 2;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P22_2)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt22PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt22PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt22CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt22CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt22CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt22CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[2] to P22_2");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P22_3 as TRACEDATA[3] -->
        <sequence name="SetupTracePin_P22_3">
          <block>
            __var pin = 3;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P22_3)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt22PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt22PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt22CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt22CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt22CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt22CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[3] to P22_3");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P22_4 as TRACECLK -->
        <sequence name="SetupTracePin_P22_4">
          <block>
            __var pin = 4;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_clock' signal (P22_4)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt22PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt22PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt22CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt22CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt22CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt22CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACECLK to P22_4");
            </block>
          </control>
        </sequence>
        <!-- Make required steps for flash operations -->
        <sequence name="FlashPreparation">
          <control if="__ap == 2">
            <block>
              // Use CM0+ ap for nested sequences
              __ap = 1;
              Sequence("PrepareCM0");
              Sequence("EnableCM7Clock");
              Sequence("PowerUpCM7_0");
            </block>
          </control>
        </sequence>
        <!-- Make sure that the application on CM0+ has prepared the CM7 core for debugging.  -->
        <sequence name="DebuggingReadiness">
          <control if="__ap == 1">
            <block>
              Sequence("EnableCM7Clock");
              Sequence("PowerUpCM7_0");
            </block>
          </control>
          <control if="__ap == 2">
            <block>
              // Use CM0+ ap for nested sequences
              __ap = 1;
              Sequence("CheckCM7Clock");
              Sequence("CheckPowerCM7_0");
            </block>
          </control>
        </sequence>
        <sequence name="DebugCoreStart" Pname="Cortex-M7-0">
          <block>
            // System Control Space (SCS) offset as defined in Armv6-M/Armv7-M.
            __var SCS_Addr   = 0xE000E000;
            __var DHCSR_Addr = SCS_Addr + 0xDF0;
            // Enable Core Debug via DHCSR
            Write32(DHCSR_Addr, 0xA05F0001);
          </block>
          <!-- Enable clock to ETM block for proper ETM detection if Parallel Trace Port enabled and it is Debug session -->
          <control if="((__connection &amp; 0x00000001) != 0) &amp;&amp; ((__traceout &amp; 0x00000002) != 0)">
            <block>
              Sequence("SetupTraceClock");
            </block>
          </control>
        </sequence>
        <!-- Configure trace clock and pins -->
        <sequence name="TraceStart" Pname="Cortex-M7-0">
          <block>
            __var CSTFCTL_Addr = 0xE008C000;
            __var CSTFCTL_Mask = 0x00000003; // Enable slave ports #0 and #1 mask for CM7_0 core
            __var reg;
            // Configure Coresight TF(Trace Funnel)
            reg = Read32(CSTFCTL_Addr);
            reg |= CSTFCTL_Mask;
            Write32(CSTFCTL_Addr, reg);
            // Configure pins
            Sequence("SetupTracePins");
          </block>
        </sequence>
      </sequences>
      <device Dname="CYT3BB5CEE">
        <compile define="CYT3BB5CEE" />
        <feature type="QFP" n="100"/>
        <feature type="Temp" n="-40" m="125"/>
        <feature type="ADC" n="39" m="12"/>
        <feature type="LIN" n="9"/>
        <feature type="I2S" n="2"/> 
      </device>
      <device Dname="CYT3BB5CES">
        <compile define="CYT3BB5CES"/>
        <feature type="QFP" n="100"/>
        <feature type="Temp" n="-40" m="105"/>
        <feature type="ADC" n="39" m="12"/>
        <feature type="LIN" n="9"/>
        <feature type="I2S" n="2"/>
      </device>
      <device Dname="CYT3BB7CEE">
        <compile define="CYT3BB7CEE" />
        <feature type="QFP" n="144"/>
        <feature type="Temp" n="-40" m="125"/>
        <feature type="ADC" n="54" m="12"/>
        <feature type="LIN" n="12"/>
        <feature type="I2S" n="3"/>
      </device>
      <device Dname="CYT3BB7CES">
        <compile define="CYT3BB7CES" />
        <feature type="QFP" n="144"/>
        <feature type="Temp" n="-40" m="105"/>
        <feature type="ADC" n="54" m="12"/>
        <feature type="LIN" n="12"/>
        <feature type="I2S" n="3"/>
      </device>
      <device Dname="CYT3BB8CEE">
        <compile define="CYT3BB8CEE" />
        <feature type="QFP" n="176"/>
        <feature type="Temp" n="-40" m="125"/>
        <feature type="ADC" n="64" m="12"/>
        <feature type="LIN" n="16"/>
        <feature type="I2S" n="3"/>
      </device>
      <device Dname="CYT3BB8CES">
        <compile define="CYT3BB8CES" />
         <feature type="QFP" n="176"/>
        <feature type="Temp" n="-40" m="105"/>
        <feature type="ADC" n="64" m="12"/>
        <feature type="LIN" n="16"/>
        <feature type="I2S" n="3"/>
      </device>
      <device Dname="CYT3BBBCEE">
        <compile define="CYT3BBBCEE" />
        <feature type="BGA" n="272"/>
        <feature type="Temp" n="-40" m="125"/>
        <feature type="ADC" n="72" m="12"/>
        <feature type="LIN" n="16"/>
        <feature type="I2S" n="3"/>
      </device>
      <device Dname="CYT3BBBCES">
        <compile define="CYT3BBBCES" />
        <feature type="BGA" n="272"/>
        <feature type="Temp" n="-40" m="105"/>
        <feature type="ADC" n="72" m="12"/>
        <feature type="LIN" n="16"/>
        <feature type="I2S" n="3"/>
      </device>
    </subFamily>
    <!-- CYT4BB: 4160KB Flash, Tri-Core -->
    <subFamily DsubFamily="CYT4BB">
      <processor Pname="Cortex-M0p" Dcore="Cortex-M0+" DcoreVersion="r0p1" Dfpu="NO_FPU" Dmpu="MPU" Dendian="Little-endian" Dclock="50000000" />
      <processor Pname="Cortex-M7-0" Dcore="Cortex-M7" DcoreVersion="r1p2" Dfpu="SP_FPU" Dmpu="MPU" Dendian="Little-endian" Dclock="250000000" />
      <processor Pname="Cortex-M7-1" Dcore="Cortex-M7" DcoreVersion="r1p2" Dfpu="SP_FPU" Dmpu="MPU" Dendian="Little-endian" Dclock="250000000" />
      <debugconfig default="swd" clock="2000000" sdf="Debug/cat1c.sdf" />
      <description>
        CYT4BB: Tri-core Cortex-M7/M7/M0+ MCU series with programmable digital and analog peripherals.
      </description>
      <debug Pname="Cortex-M7-1" svd="Libraries/mtb-pdl-cat1/devices/COMPONENT_CAT1C/svd/cat1c4m.svd" __ap="3" defaultResetSequence="ResetSystem" />
      <debug Pname="Cortex-M7-0" svd="Libraries/mtb-pdl-cat1/devices/COMPONENT_CAT1C/svd/cat1c4m.svd" __ap="2" defaultResetSequence="ResetSystem" />
      <debug Pname="Cortex-M0p" svd="Libraries/mtb-pdl-cat1/devices/COMPONENT_CAT1C/svd/cat1c4m.svd" __ap="1" defaultResetSequence="ResetProcessor" />
      <memory name="SRAM" access="rwx" start="0x28000000" size="0xC0000" default="1" />
      <memory name="FLASH" access="rx" start="0x10000000" size="0x410000" default="1" startup="1" />
      <algorithm Pname="Cortex-M0p" name="Flash/CAT1C_4160.FLM" start="0x10000000" size="0x00410000" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M0p" name="Flash/CAT1C_WFLASH_256.FLM" start="0x14000000" size="0x00040000" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M0p" name="Flash/CAT1C_SFLASH_USER.FLM" start="0x17000800" size="0x00000800" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M0p" name="Flash/CAT1C_SFLASH_NAR.FLM" start="0x17001A00" size="0x00000200" RAMstart="0x28001000" RAMsize="0xFFF0" default="0" style="Keil" />
      <algorithm Pname="Cortex-M0p" name="Flash/CAT1C_SFLASH_PKEY.FLM" start="0x17006400" size="0x00000C00" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M0p" name="Flash/CAT1C_SFLASH_TOC2.FLM" start="0x17007C00" size="0x00000200" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M0p" name="Flash/CAT1C_SMIF.FLM" start="0x60000000" size="0x08000000" RAMstart="0x28001000" RAMsize="0xFFF0" default="0" style="Keil" />
      <algorithm Pname="Cortex-M7-0" name="Flash/CAT1C_4160.FLM" start="0x10000000" size="0x00410000" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M7-0" name="Flash/CAT1C_WFLASH_256.FLM" start="0x14000000" size="0x00040000" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M7-0" name="Flash/CAT1C_SFLASH_USER.FLM" start="0x17000800" size="0x00000800" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M7-0" name="Flash/CAT1C_SFLASH_NAR.FLM" start="0x17001A00" size="0x00000200" RAMstart="0x28001000" RAMsize="0xFFF0" default="0" style="Keil" />
      <algorithm Pname="Cortex-M7-0" name="Flash/CAT1C_SFLASH_PKEY.FLM" start="0x17006400" size="0x00000C00" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M7-0" name="Flash/CAT1C_SFLASH_TOC2.FLM" start="0x17007C00" size="0x00000200" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M7-0" name="Flash/CAT1C_SMIF.FLM" start="0x60000000" size="0x08000000" RAMstart="0x28001000" RAMsize="0xFFF0" default="0" style="Keil" />
      <algorithm Pname="Cortex-M7-1" name="Flash/CAT1C_4160.FLM" start="0x10000000" size="0x00410000" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M7-1" name="Flash/CAT1C_WFLASH_256.FLM" start="0x14000000" size="0x00040000" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M7-1" name="Flash/CAT1C_SFLASH_USER.FLM" start="0x17000800" size="0x00000800" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M7-1" name="Flash/CAT1C_SFLASH_NAR.FLM" start="0x17001A00" size="0x00000200" RAMstart="0x28001000" RAMsize="0xFFF0" default="0" style="Keil" />
      <algorithm Pname="Cortex-M7-1" name="Flash/CAT1C_SFLASH_PKEY.FLM" start="0x17006400" size="0x00000C00" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M7-1" name="Flash/CAT1C_SFLASH_TOC2.FLM" start="0x17007C00" size="0x00000200" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M7-1" name="Flash/CAT1C_SMIF.FLM" start="0x60000000" size="0x08000000" RAMstart="0x28001000" RAMsize="0xFFF0" default="0" style="Keil" />
      <book name="https://www.infineon.com/dgdl/Infineon-TRAVEO_T2G_automotive_microcontroller_CYT3BB_4BB_32-BIT_ARM_CORTEX-M7-DataSheet-v11_00-EN.pdf?fileId=5546d4627883d7e00178a73ba6ad1732" title="TRAVEO™ T2G CYT3BB/CYT4BB Series Data Sheet"/>
      <book name="https://www.infineon.com/sec/login?ret=https%3A%2F%2Fwww.infineon.com%2Fcms%2Fen%2Fproduct%2Fmicrocontroller%2F32-bit-traveo-t2g-arm-cortex-microcontroller%2F32-bit-traveo-t2g-arm-cortex-for-body%2Ftraveo-t2g-cyt3bb-cyt4bb-series%2F%23!documents%2Fdocument-group-myInfineon-57" title="TRAVEO™ T2G CYT3BB/CYT4BB TRM"/>
      <book name="https://www.infineon.com/cms/en/product/microcontroller/32-bit-traveo-t2g-arm-cortex-microcontroller/32-bit-traveo-t2g-arm-cortex-for-body/traveo-t2g-cyt3bb-cyt4bb-series/" title="Overview of TRAVEO™ T2G CYT3BB/CYT4BB Series"/>
      <debugvars configfile="Debug/cat1c.dbgconf" version="1.0">
        __var __TPIU_pinlocation = 1;                      // Select one of the possible TPIU pin locations
        __var __TPIU_clocksetup = 1;                       // Enable(1) or Disable(0) setup of trace source clock
        __var __TPIU_clockdivval = 0;                      // Clock divider value for trace clock
        // TraceClock configuration data
        __var TRACE_CLOCK_CTL_ADDR = 0x40040C00;           // Clock control register for cpuss.clock_trace_in
        __var TRACE_CLOCK_DIV_CTL_ADDR = 0x40041020;       // Divider control (for 8.0 divider)
        __var TRACE_CLOCK_DIV_CMD_ADDR = 0x40040000;       // Divider command
        __var PERI_CLOCK_CTL_DIV_SEL = 0x02;               // CYT4BB devices have 3 of 8-bit dividers - use the lastest available for tracing
        __var PERI_DIV_PA_SEL_MASK = 0x000003FF;           // PA_TYPE_SEL + PA_DIV_SEL fields mask (size)
        __var PERI_DIV_CMD_PA_SEL_ROL = 0x00000010;        // PA_TYPE_SEL + PA_DIV_SEL fields offset in PERI_DIV_CMD
        // TPIU pins configuration data
        __var hsiomPrt21PortSel0Addr = 0x40300150;  // HSIOM_PRT[port]_PORT_SEL0·register·address. Port 21 selection 0
        __var hsiomPrt22PortSel0Addr = 0x40300160;  // HSIOM_PRT[port]_PORT_SEL0·register·address. Port 22 selection 0
        __var gpioPrt21CfgAddr = 0x40310AC4;        // GPIO_PRT[port]_CFG register address. Port 21 configuration
        __var gpioPrt22CfgAddr = 0x40310B44;        // GPIO_PRT[port]_CFG register address. Port 22 configuration
        __var gpioPrt21CfgOutAddr = 0x40310ACC;     // GPIO_PRT[port]_CFG_OUT register address. Port 21 output buffer configuration
        __var gpioPrt22CfgOutAddr = 0x40310B4C;     // GPIO_PRT[port]_CFG_OUT register address. Port 22 output buffer configuration
      </debugvars>
      <sequences>
        <sequence name="DebugPortStart">
          <block info="Read DP CTRL/STAT">
            __var SW_DP_ABORT  = 0x0;
            __var DP_CTRL_STAT = 0x4;
            __var DP_SELECT    = 0x8;
            __var powered_down = 0;
            // Switch to DP Register Bank 0. Explicitly set APSEL to current AP selection
            WriteDP(DP_SELECT, __ap &lt;&lt; 24);
            // Read DP CTRL/STAT Register and check if CSYSPWRUPACK and CDBGPWRUPACK bits are set
            powered_down = ((ReadDP(DP_CTRL_STAT) &amp; 0xA0000000) != 0xA0000000);
          </block>
          <control if="powered_down">
            <block info="Power Up System &amp; Debug">
              // Request Debug/System Power-Up
              // Ignore error here: even there is a polling in the next block, CMSIS-DAP transports reads DP.RDBUFF register
              // right after write to DP.CTRL_STAT. This will fail for some cases - for example if device is waking from DeepSleep.
              __errorcontrol = 1;
              WriteDP(DP_CTRL_STAT, 0x50000000);
              __errorcontrol = 0;
            </block>
            <!-- Wait for Power-Up Request to be acknowledged -->
            <control while="(ReadDP(DP_CTRL_STAT) &amp; 0xA0000000) != 0xA0000000" timeout="1000000" info="Wait for power acknowledged" />
            <!-- CDBGRSTREQ on CAT1C behaves like Power-On Reset. Not desired when starting the Debug Port
            <block info="Debug Reset">
              __errorcontrol = 1;
              // Request Debug Reset
              WriteDP(DP_CTRL_STAT, 0x54000000);
              // CDBGRSTREQ is equivalent to Power-On Reset and fully reboots the device.
              // Depending on the user application the reboot can take up to 600ms.
              DAP_Delay(600000);
              __errorcontrol = 0;
            </block>
            -->
            <!-- Wait for Debug Reset to be acknowledged, don't issue error on timeout to deal with improperly connected Debug Reset -->
            <!-- <control while="(ReadDP(DP_CTRL_STAT) &amp; 0xA8000000) != 0xA8000000" timeout="300000" info="Wait for Debug Reset Acknowledge"/> -->
            <!-- JTAG Specific Part of sequence -->
            <control if="(__protocol &amp; 0xFFFF) == 1">
              <block info="JTAG: Clear Sticky Bits">
                // Init AP Transfer Mode, Transaction Counter, and Lane Mask (Normal Transfer Mode, Include all Byte Lanes)
                // Additionally clear STICKYORUN, STICKYCMP, and STICKYERR bits by writing '1'
                WriteDP(DP_CTRL_STAT, 0x50000F32);
              </block>
            </control>
            <!-- SWD Specific Part of sequence -->
            <control if="(__protocol &amp; 0xFFFF) == 2">
              <block info="SWD: Init SWD &amp; Clear Sticky Bits">
                // Init AP Transfer Mode, Transaction Counter, and Lane Mask (Normal Transfer Mode, Include all Byte Lanes)
                WriteDP(DP_CTRL_STAT, 0x50000F00);
                // Clear WDATAERR, STICKYORUN, STICKYCMP, and STICKYERR bits of CTRL/STAT Register by write to ABORT register
                WriteDP(SW_DP_ABORT, 0x0000001E);
              </block>
            </control>
          </control>
          <control if="(__connection &amp; 3) == 2">
            <block>
              // Prepare MCU for flash operations
              Sequence("FlashPreparation");
            </block>
          </control>
          <control if="(__connection &amp; 3) == 1">
            <block>
              // Checking core readiness for debugging
              Sequence("DebuggingReadiness");
            </block>
          </control>
          <block>
            // Print device info
            Sequence("PrintDeviceInfo");
          </block>
        </sequence>
        <!-- HW Reset causes a reboot of the device which also resets debug.
             - Using this as a prereset is OK to potentially wake up the system from DeepSleep.
             - Using this in the middle of the debug session will break the connection unless recovery
               from a connection loss is supported by the debug IDE.
        -->
        <sequence name="ResetHardware">
          <block>
            __var nReset      = 0x80;
            __var canReadPins = 0;
            // Deassert nRESET line
            canReadPins = (DAP_SWJ_Pins(0x00, nReset, 0) != 0xFFFFFFFF);
          </block>
          <!-- Keep reset active for 50 ms -->
          <control while="1" timeout="50000" />
          <control if="canReadPins">
            <!-- Assert nRESET line and wait max. 1s for recovery -->
            <control while="(DAP_SWJ_Pins(nReset, nReset, 0) &amp; nReset) == 0" timeout="1000000" />
          </control>
          <control if="!canReadPins">
            <block>
              // Assert nRESET line
              DAP_SWJ_Pins(nReset, nReset, 0);
            </block>
            <!-- Wait 100ms for recovery if nRESET not readable -->
            <control while="1" timeout="100000" />
          </control>
          <block>
            // Give the bootloader time to finish (can be up to 600ms)
            DAP_Delay(600000);
          </block>
        </sequence>
        <sequence name="ResetSystem" Pname="Cortex-M0p">
          <block info="Halt CPU and determine application entry point">
            // System Control Space (SCS) offset as defined in Armv6-M/Armv7-M.
            __var SCS_Addr = 0xE000E000;
            __var AIRCR_Addr = SCS_Addr + 0xD0C;
            __var DHCSR_Addr = SCS_Addr + 0xDF0;
            __var BP_CTRL = 0xE0002000;
            __var BP_COMPx = 0xE0002008;
            __var DP_CTRL_STAT = 0x4;
            __var appValid = 0;
            __var vtBase = 0;
            __var resetAddress = 0;

            // Read VT_BASE register
            vtBase = Read32(0x40201120) &amp; 0xFFFF0000;
            appValid = (vtBase != 0) &amp;&amp; (vtBase != 0xFFFF0000);
          </block>
          <control if="appValid">
            <block info="Set BP at app entry and issue a reset">
              //Get application address at reset vector
              resetAddress = Read32(vtBase + 4);
            </block>
            <control if="(resetAddress != 0) &amp;&amp; (resetAddress != 0xFFFFFFFF)">
              <block>
                // Enable debug, and halt the CPU
                Write32(DHCSR_Addr, 0xA05F0003);

                // Enable Breakpoint unit using the BP_CTRL
                Write32(0xE0002000, 0x00000003);

                // Map the address bits to the breakpoint compare register
                resetAddress = (resetAddress &amp; 0x1FFFFFFC) | 0xC0000001;

                // Update the breakpoint compare register
                Write32(0xE0002008, resetAddress);

                // Issue software reset using the AIRCR (Application Interrupt and Reset
                // Control Register). Note: do not check for ACK_OK of this operation
                __errorcontrol = 1;
                Write32(AIRCR_Addr, 0x05FA0004);
                sequence("DAP_poll");
                __errorcontrol = 0;
              </block>
              <!-- Reset Recovery: Wait for CPUSS_CM0_CTL to  bit to clear on read -->
              <control while="(Read32(DHCSR_Addr) &amp; 0x02000000)" timeout="500000" />
              <block>
                // Enable CM7 core(s) in order to be able to attach to it
                Sequence("DebuggingReadiness");
              </block>
            </control>
          </control>
        </sequence>
        <!-- Cortex-M0+ Processor reset via XMC7xxx CPU Sub-System Controller. Cortex-M0+ doesn't have VECTRESET. -->
        <sequence name="ResetProcessor" Pname="Cortex-M0p">
          <block>
            __var CPUSS_CM0_CTL_Addr = 0x40201000;    // CM0+ Control Register
            __var DHCSR_Addr = 0xE000EDF0;
            Write32(CPUSS_CM0_CTL_Addr, 0x05FA0000);  // Reset CM0+
          </block>
          <!-- Reset Recovery: Wait for CPUSS_CM0_CTL to  bit to clear on read -->
          <control while="(Read32(DHCSR_Addr) &amp; 0x02000000)" timeout="500000" />
        </sequence>
        <!-- Prepare CM0+ core to serve SROM API calls -->
        <sequence name="PrepareCM0">
          <block>
            __var WFI_LOOP_ADDR = 0x28000000 + 0x800;
            __var CM0_SP_ADDR = WFI_LOOP_ADDR + 0x40;
            // Halt CM0+
              Write32(0xE000EDF0, 0xA05F0003);
          </block>
          <control while="(Read32(0xE000EDF0) &amp; 0x00030000) != 0x00030000" timeout="1000000" info="Wait for core halts" />
          <block>
            // Write WFI loop in RAM
            Write32(WFI_LOOP_ADDR, 0xE7FDBF30);
            // Set VECTCLRACTIVE in AIRCR for CM0+
            Write32(0xE000ED0C, 0x05FA0002);
            // Write CM0+ xPSR
            Write32(0xE000EDF8, 0x01000000);
            Write32(0xE000EDF4, 0x00010010);
          </block>
          <control while="(Read32(0xE000EDF0) &amp; 0x00010000) != 0x00010000" timeout="1000000" info="Wait for register transfer to complete" />
          <block>
            // Write CM0+ CONTROL, PRIMASK
            Write32(0xE000EDF8, 0x00000000);
            Write32(0xE000EDF4, 0x00010014);
          </block>
          <control while="(Read32(0xE000EDF0) &amp; 0x00010000) != 0x00010000" timeout="1000000" info="Wait for register transfer to complete" />
          <block>
            // Write CM0+ PC
            Write32(0xE000EDF8, WFI_LOOP_ADDR);
            Write32(0xE000EDF4, 0x0001000F);
          </block>
          <control while="(Read32(0xE000EDF0) &amp; 0x00010000) != 0x00010000" timeout="1000000" info="Wait for register transfer to complete" />
          <block>
            // Write CM0+ SP
            Write32(0xE000EDF8, CM0_SP_ADDR);
            Write32(0xE000EDF4, 0x0001000D);
          </block>
          <control while="(Read32(0xE000EDF0) &amp; 0x00010000) != 0x00010000" timeout="1000000" info="Wait for register transfer to complete" />
          <block>
            // Write CM0+ VTOR
            Write32(0xE000ED08, 0x00000000);
            // Clear all pending interrupts in CM0+
            Write32(0xE000E280, 0x0000FFFF);
            // Enable only CM0+ IRQ0/1
            Write32(0xE000E180, 0xFFFFFFFC);
            Write32(0xE000E100, 0x00000003);
            // Set priority of IRQ0=1, IRQ1=0. Need to make sure IRQ1 is triggered even if IRQ0 is pending.
            Write32(0xE000E400, 0x00000040);
            // Release CM0+ from halt state
            Write32(0xE000EDF0, 0xA05F0001);
          </block>
        </sequence>
        <sequence name="DAP_Handshake">
          <!-- DAP_Handshake: Execute initial handshake sequence depend on selected protocol -->
          <block>
            __var isSWJ      = ((__protocol &amp; 0x00010000) != 0);
            __var protType   = __protocol &amp; 0x0000FFFF;
            __var DPIDR = 0;
            __Result = 0;
          </block>
          <!-- JTAG Protocol -->
          <control if="protType == 1">
            <control if="isSWJ">
              <block atomic="true">
                // Ensure current debug interface is in reset state
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF);
                // Execute SWJ-DP Switch Sequence SWD to JTAG (0xE73C)
                // Change if SWJ-DP uses deprecated switch code (0xAEAE)
                DAP_SWJ_Sequence(16, 0xE73C);
              </block>
            </control>
            <block atomic="true">
              // JTAG "Soft" Reset
              DAP_JTAG_Sequence(6, 1, 0x00);                        // Test-Logic-Reset
              // Get IDCODE to make shure that JTAG-DP is available
              DAP_JTAG_Sequence(4, 0, 0x00);                        // 4*Run-Test/Idle
              DAP_JTAG_Sequence(2, 1, 0x00);                        // ~ Select-DR ~ Select-IR
              DAP_JTAG_Sequence(2, 0, 0x00);                        // ~ Capture-IR ~ Shift-IR
              DAP_JTAG_Sequence(8, 0, 0xFE);                        // Shift-IR (IDCODE BYPASS)
              DAP_JTAG_Sequence(5, 1, 0x00);                        // ~ Exit1-IR (IDCODE BYPASS) ~ Update-IR ~ Test-Logic-Reset
              DAP_JTAG_Sequence(4, 0, 0x00);                        // Make sure that we go through Idle state in TAP controller
              DAP_JTAG_Sequence(1, 1, 0x00);                        // Select-DR
              DAP_JTAG_Sequence(2, 0, 0x00);                        // ~ Capture-DR ~ Shift-DR
              DPIDR = DAP_JTAG_Sequence(33, 0, 0x00000000);         // Shift 33-bits data
              DAP_JTAG_Sequence(5, 1, 0x00);                        // ~ Exit1-DR ~ Update-DR ~ ~ Select-DR ~ Select-IR ~ Test-Logic-Reset
              DAP_JTAG_Sequence(4, 0, 0x00);                        // Make sure that we go through Idle state in TAP controller
            </block>
          </control>
          <!-- SWD Protocol -->
          <control if="protType == 2">
            <control if="isSWJ">
              <block atomic="true">
                // Ensure current debug interface is in reset state
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF);
                // Execute SWJ-DP Switch Sequence JTAG to SWD (0xE79E)
                // Change if SWJ-DP uses deprecated switch code (0xEDB6)
                DAP_SWJ_Sequence(16, 0xE79E);
                // Enter SWD Line Reset State
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // More than 50 cycles SWDIO/TMS High
                DAP_SWJ_Sequence(3,  0x00);               // At least 2 idle cycles (SWDIO/TMS Low)
              </block>
            </control>
            <control if="!isSWJ">
              <block atomic="true">
                // Enter SWD Line Reset State
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // More than 50 cycles SWDIO/TMS High
                DAP_SWJ_Sequence(3,  0x00);               // At least 2 idle cycles (SWDIO/TMS Low)
              </block>
            </control>
            <block>
              DPIDR = ReadDP(0x0); // Read DPIDR to enable SWD interface (SW-DPv1 and SW-DPv2)
            </block>
          </control>
          <control if="(DPIDR &amp; 0xFFF00FFF) != 0x6BA00477">
            <block>
              __Result = -1; // DAP is unavailable
            </block>
          </control>
        </sequence>
        <sequence name="DAP_poll">
          <!-- DAP_poll: Poll the DAP until it becomes available -->
          <block>
            __Result = -1; // Assume DAP is not available yet
          </block>
          <control while="__Result != 0" timeout="600000">
            <block>
              sequence("DAP_Handshake"); // Poll DP until bootloader allows access to device (can be up to 600ms)
            </block>
          </control>
          <control if="__Result != 0">
            <block>
              Message(1, "The Debug Access Port is unavailable.");
            </block>
          </control>
        </sequence>
        <!-- Enable CM7 clock -->
        <sequence name="EnableCM7Clock">
          <block>
            __var CLK_ROOT_SELECT = Read32(0x40261244);
          </block>
          <control if="(CLK_ROOT_SELECT &amp; 0x80000000) != 0x80000000">
            <block>
              Write32(0x40261244, (CLK_ROOT_SELECT | 0x80000000));
              Message(0, "CLK_HF1 was enabled.");
            </block>
          </control>
        </sequence>
        <!-- Set power mode of CM7_0 core to ENABLED -->
        <sequence name="PowerUpCM7_0">
          <block>
            __var CM7_PWR_CTL_ADDR = 0x40201200;
            __var CM7_PWR_CTL = Read32(CM7_PWR_CTL_ADDR);
          </block>
          <control if="(CM7_PWR_CTL &amp; 0x3) != 0x3">
            <block>
              // Set power mode of CM7
              Write32(CM7_PWR_CTL_ADDR, 0x05FA0003);
              Message(0, "The power mode of Cortex-M7_0 core was set to ENABLED.");
            </block>
          </control>
          <!-- Set power mode of CM7 to ENABLED. The core will stop at reset vector -->
          <block>
            __var CPUSS_CM7_CTL_ADDR = 0x4020000C;
            __var CPUSS_CM7_CTL = Read32(CPUSS_CM7_CTL_ADDR);
          </block>
          <control if="CPUSS_CM7_CTL &amp; 0x10">
            <block>
              // Deassert CPU_WAIT
              Write32(CPUSS_CM7_CTL_ADDR, (CPUSS_CM7_CTL &amp; 0xFFFFFFEF));
              Message(0, "CPU_WAIT of Cortex-M7_0 core was deasserted.");
            </block>
          </control>
        </sequence>
        <!-- Check CM7 clock -->
        <sequence name="CheckCM7Clock">
          <block>
            __var CLK_ROOT_SELECT = Read32(0x40261244);
          </block>
          <control if="(CLK_ROOT_SELECT &amp; 0x80000000) != 0x80000000">
            <block>
              Message(2, "The CM7 core clock source (CLK_HF1) is not enabled by the CM0+ application. Further debugging is not possible.");
            </block>
          </control>
        </sequence>
        <!-- Check power mode of CM7_0 core  -->
        <sequence name="CheckPowerCM7_0">
          <block>
            __var CM7_PWR_CTL_ADDR = 0x40201200;
            __var CM7_PWR_CTL = Read32(CM7_PWR_CTL_ADDR);
          </block>
          <control if="(CM7_PWR_CTL &amp; 0x3) != 0x3">
            <block>
              Message(2, "The power mode of Cortex-M7_0 core was NOT ENABLED by the CM0+ application. Further debugging is not possible.");
            </block>
          </control>
        </sequence>
        <!-- Read and print device info -->
        <sequence name="PrintDeviceInfo">
          <block>
            __var siId;
            __var siRev;
            __var siFamily;
            __var fbVerHi;
            __var protection;
            __var v;
            Message(0, "****************************************************");
            // Get Si Id, Family and Rev.
            v = Read32(0x17000000);
            siId = (v &amp; 0xFFFF0000) &gt;&gt; 16;
            siRev = (v &amp; 0x0000FF00) &gt;&gt; 8;
            v = Read32(0x1700000C);
            siFamily = v &amp; 0x00000FFF;
            Message(0, "** Silicon: 0x%04X, Family: 0x%03X, Rev.: 0x%02X", siId, siFamily, siRev);
            // Get FlashBboot verison
            fbVerHi = Read32(0x17002004);
          </block>
          <control if="fbVerHi == 0">
            <block>
              Message(1, "Invalid FlashBoot: High version word of Flash Boot is zero");
            </block>
          </control>
          <control if="fbVerHi != 0">
            <block>
              __var fbVerLo = Read32(0x17002018);
              __var b0 = fbVerHi &gt;&gt; 28;
              __var b1 = (fbVerHi &gt;&gt; 24) &amp; 0x0F;
              __var b2 = (fbVerHi &gt;&gt; 16) &amp; 0xFF;
              __var b3 = fbVerHi &amp; 0x0000FFFF;
            </block>
            <control if="b0 &gt; 2">
              <block>
                Message(1, "Unsupported Flash Boot Version - Flash Boot Version [31:28] = 0x%X", b0);
              </block>
            </control>
            <control if="b0 &lt;= 2">
              <control if="b3 != 0x8001">
                <block>
                  Message(1, "Flash Boot is corrupted or non Flash Boot image programmed");
                </block>
              </control>
              <control if="b3 == 0x8001">
                <!-- Versioning scheme #1 -->
                <control if="b0 == 0">
                  <control if="b1 == 1">
                    <block>
                      Message(0, "** Flash Boot version: 1.%02u", b2);
                    </block>
                  </control>
                  <control if="b1 == 2">
                    <control if="b2 &lt; 20">
                      <block>
                        Message(0, "** Flash Boot version: 1.0.0.%u", b2);
                      </block>
                    </control>
                    <control if="(b2 &gt;= 20) &amp;&amp; (b2 &lt; 29)">
                      <block>
                        Message(0, "** Flash Boot version: 1.0.1.%u", b2);
                      </block>
                    </control>
                    <control if="b2 &gt;= 29">
                      <block>
                        Message(0, "** Flash Boot version: 1.20.1.%u", b2);
                      </block>
                    </control>
                  </control>
                </control>
                <!-- Versioning scheme #2 -->
                <control if="b0 == 1">
                  <block>
                    Message(0, "** Flash Boot version: 2.0.0.%u", b2);
                  </block>
                </control>
                <!-- Versioning scheme #3 -->
                <control if="b0 == 2">
                  <block>
                    __var patch = fbVerLo &gt;&gt; 24;
                    __var build = fbVerLo &amp; 0x0000FFFF;
                    Message(0, "** Flash Boot version: %u.%u.%u.%u", b1, b2, patch, build);
                  </block>
                </control>
              </control>
            </control>
          </control>
          <!-- Get life-cycle stage -->
          <control>
            <block>
              protection = Read32(0x402020C4);
            </block>
          </control>
          <!-- Decode life-cycle stage -->
          <control if="protection == 1">
            <block>
              Message(0, "** Chip Protection: VIRGIN");
            </block>
          </control>
          <control if="protection == 2">
            <block>
              Message(0, "** Chip Protection: NORMAL");
            </block>
          </control>
          <control if="protection == 3">
            <block>
              Message(0, "** Chip Protection: SECURE");
            </block>
          </control>
          <control if="protection == 4">
            <block>
              Message(0, "** Chip Protection: DEAD");
            </block>
          </control>
          <control if="(protection == 0) || (protection &gt; 4)">
            <block>
              Message(0, "** Chip Protection: UNKNOWN");
            </block>
          </control>
          <block>
            Message(0, "****************************************************");
          </block>
        </sequence>
        <sequence name="SetupTraceClock">
          <control if="__TPIU_clocksetup != 0">
            <block>
              __var PERI_CLOCK_CTL_DIV_SEL_MASK = 0x0000000F;                    // PERI_CLOCK_CTL.DIV_SEL
              __var PERI_DIV_CMD_ENABLE_MASK = 0x80000000;                       // ENABLE field in PERI_DIV_CMD
              __var PERI_DIV_CMD_DISABLE_MASK = 0x40000000;                      // DISABLE field in PERI_DIV_CMD
              // Peripheral clock divider index to use for trace clock
              __var ClockDivSel = PERI_CLOCK_CTL_DIV_SEL &amp; PERI_CLOCK_CTL_DIV_SEL_MASK;
              __var ClockDivVal = __TPIU_clockdivval &amp; PERI_DIV_PA_SEL_MASK; // Peripheral clock divider value for trace clock
                                                                                 // Actual divider is (1+ClockDivVal)
              __var ClockCtlVal = Read32(TRACE_CLOCK_CTL_ADDR);
              __var ClockDivCtlVal = Read32(TRACE_CLOCK_DIV_CTL_ADDR + (ClockDivSel * 4));
            </block>
            <control if="(ClockCtlVal != ClockDivSel) || (ClockDivCtlVal != ((ClockDivVal &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | 0x1))">
              <block>
                Message(0, "Setup TPIU clock, divider value is %u", ClockDivVal);
                // DISABLE 8.0 DIV in PERI_DIV_CMD:
                __var ClockDivCmd = PERI_DIV_CMD_DISABLE_MASK | (PERI_DIV_PA_SEL_MASK &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | ClockDivSel;
                Write32(TRACE_CLOCK_DIV_CMD_ADDR, ClockDivCmd);
                // Use selected divider (8.0) for cpuss.clock_trace_in
                Write32(TRACE_CLOCK_CTL_ADDR, ClockDivSel);
                // Set 8.0 DIV = ClockDivVal
                Write32((TRACE_CLOCK_DIV_CTL_ADDR + (ClockDivSel * 4)), (ClockDivVal &lt;&lt; 8));
                // ENABLE 8.0 DIV
                ClockDivCmd = PERI_DIV_CMD_ENABLE_MASK | (PERI_DIV_PA_SEL_MASK &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | ClockDivSel;
                Write32(TRACE_CLOCK_DIV_CMD_ADDR, ClockDivCmd);
              </block>
            </control>
          </control>
        </sequence>
        <!-- Configure pins trace pins if Parallel Trace Port enabled -->
        <sequence name="SetupTracePins">
          <control if="(__traceout &amp; 0x00000002) != 0" info="Parallel Trace Port enabled">
            <control if="__TPIU_pinlocation == 1" info="XMC72_EVK Kit like">
              <block>
                __var tpWidth = (__traceout &amp; 0x003F0000) &gt;&gt; 16;
                sequence("SetupTracePin_P22_4"); // TRACECLK
                sequence("SetupTracePin_P21_5"); // TRACEDATA[0]
              </block>
              <control if="tpWidth &gt; 1">
                <block>
                  sequence("SetupTracePin_P22_1"); // TRACEDATA[1]
                </block>
              </control>
              <control if="tpWidth &gt; 2">
                <block>
                  sequence("SetupTracePin_P22_2"); // TRACEDATA[2]
                  sequence("SetupTracePin_P22_3"); // TRACEDATA[3]
                </block>
              </control>
            </control>
          </control>
        </sequence>
        <!-- Setup Trace Pin 21_5 as TRACEDATA[0]  -->
        <sequence name="SetupTracePin_P21_5">
          <block>
            __var pin = 5;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P21_5)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt21PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt21PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt21CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt21CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt21CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt21CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[0] to P21_5");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P22_1 as TRACEDATA[1] -->
        <sequence name="SetupTracePin_P22_1">
          <block>
            __var pin = 1;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P22_1)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt22PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt22PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt22CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt22CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt22CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt22CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[1] to P22_1");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P22_2 as TRACEDATA[2] -->
        <sequence name="SetupTracePin_P22_2">
          <block>
            __var pin = 2;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P22_2)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt22PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt22PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt22CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt22CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt22CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt22CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[2] to P22_2");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P22_3 as TRACEDATA[3] -->
        <sequence name="SetupTracePin_P22_3">
          <block>
            __var pin = 3;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P22_3)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt22PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt22PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt22CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt22CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt22CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt22CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[3] to P22_3");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P22_4 as TRACECLK -->
        <sequence name="SetupTracePin_P22_4">
          <block>
            __var pin = 4;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_clock' signal (P22_4)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt22PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt22PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt22CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt22CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt22CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt22CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACECLK to P22_4");
            </block>
          </control>
        </sequence>
        <!-- Set power mode of CM7_1 core to ENABLED -->
        <sequence name="PowerUpCM7_1">
          <block>
            __var CM7_PWR_CTL_ADDR = 0x40201210;
            __var CM7_PWR_CTL = Read32(CM7_PWR_CTL_ADDR);
          </block>
          <control if="(CM7_PWR_CTL &amp; 0x3) != 0x3">
            <block>
              // Set power mode of CM7
              Write32(CM7_PWR_CTL_ADDR, 0x05FA0003);
              Message(0, "The power mode of Cortex-M7_1 core was set to ENABLED.");
            </block>
          </control>
          <!-- Set power mode of CM7 to ENABLED. The core will stop at reset vector -->
          <block>
            __var CPUSS_CM7_CTL_ADDR = 0x4020040C;
            __var CPUSS_CM7_CTL = Read32(CPUSS_CM7_CTL_ADDR);
          </block>
          <control if="CPUSS_CM7_CTL &amp; 0x10">
            <block>
              // Deassert CPU_WAIT
              Write32(CPUSS_CM7_CTL_ADDR, (CPUSS_CM7_CTL &amp; 0xFFFFFFEF));
              Message(0, "CPU_WAIT of Cortex-M7_1 core was deasserted.");
            </block>
          </control>
        </sequence>
        <!-- Make required steps for flash operations -->
        <sequence name="FlashPreparation">
          <control if="__ap == 2">
            <block>
              // Use CM0+ ap for nested sequences
              __ap = 1;
              Sequence("PrepareCM0");
              Sequence("EnableCM7Clock");
              Sequence("PowerUpCM7_0");
            </block>
          </control>
          <control if="__ap == 3">
            <block>
              // Use CM0+ ap for nested sequences
              __ap = 1;
              Sequence("PrepareCM0");
              Sequence("EnableCM7Clock");
              Sequence("PowerUpCM7_1");
            </block>
          </control>
        </sequence>
        <!-- Check power mode of CM7_1 core  -->
        <sequence name="CheckPowerCM7_1">
          <block>
            __var CM7_PWR_CTL_ADDR = 0x40201210;
            __var CM7_PWR_CTL = Read32(CM7_PWR_CTL_ADDR);
          </block>
          <control if="(CM7_PWR_CTL &amp; 0x3) != 0x3">
            <block>
              Message(2, "The power mode of Cortex-M7_1 core was NOT ENABLED by the CM0+ application. Further debugging is not possible.");
            </block>
          </control>
        </sequence>
        <!-- Make sure that the application on CM0+ has prepared the CM7 core for debugging.  -->
        <sequence name="DebuggingReadiness">
          <control if="__ap == 1">
            <block>
              Sequence("EnableCM7Clock");
              Sequence("PowerUpCM7_0");
              Sequence("PowerUpCM7_1");
            </block>
          </control>
          <control if="__ap == 2">
            <block>
              // Use CM0+ ap for nested sequences
              __ap = 1;
              Sequence("CheckCM7Clock");
              Sequence("CheckPowerCM7_0");
            </block>
          </control>
          <control if="__ap == 3">
            <block>
              // Use CM0+ ap for nested sequences
              __ap = 1;
              Sequence("CheckCM7Clock");
              Sequence("CheckPowerCM7_1");
            </block>
          </control>
        </sequence>
        <sequence name="DebugCoreStart" Pname="Cortex-M7-0">
          <block>
            // System Control Space (SCS) offset as defined in Armv6-M/Armv7-M.
            __var SCS_Addr   = 0xE000E000;
            __var DHCSR_Addr = SCS_Addr + 0xDF0;
            // Enable Core Debug via DHCSR
            Write32(DHCSR_Addr, 0xA05F0001);
          </block>
          <!-- Enable clock to ETM block for proper ETM detection if Parallel Trace Port enabled and it is Debug session -->
          <control if="((__connection &amp; 0x00000001) != 0) &amp;&amp; ((__traceout &amp; 0x00000002) != 0)">
            <block>
              Sequence("SetupTraceClock");
            </block>
          </control>
        </sequence>
        <sequence name="DebugCoreStart" Pname="Cortex-M7-1">
          <block>
            // System Control Space (SCS) offset as defined in Armv6-M/Armv7-M.
            __var SCS_Addr   = 0xE000E000;
            __var DHCSR_Addr = SCS_Addr + 0xDF0;
            // Enable Core Debug via DHCSR
            Write32(DHCSR_Addr, 0xA05F0001);
          </block>
          <!-- Enable clock to ETM block for proper ETM detection if Parallel Trace Port enabled and it is Debug session -->
          <control if="((__connection &amp; 0x00000001) != 0) &amp;&amp; ((__traceout &amp; 0x00000002) != 0)">
            <block>
              Sequence("SetupTraceClock");
            </block>
          </control>
        </sequence>
        <!-- Configure trace clock and pins -->
        <sequence name="TraceStart" Pname="Cortex-M7-0">
          <block>
            __var CSTFCTL_Addr = 0xE008C000;
            __var CSTFCTL_Mask = 0x00000003; // Enable slave ports #0 and #1 mask for CM7_0 core
            __var reg;
            // Configure Coresight TF(Trace Funnel)
            reg = Read32(CSTFCTL_Addr);
            reg |= CSTFCTL_Mask;
            Write32(CSTFCTL_Addr, reg);
            // Configure pins
            Sequence("SetupTracePins");
          </block>
        </sequence>
        <sequence name="TraceStart" Pname="Cortex-M7-1">
          <block>
            __var CSTFCTL_Addr = 0xE008C000;
            __var CSTFCTL_Mask = 0x0000000C; // Enable slave ports #2 and #3 mask for CM7_1 core
            __var reg;
            // Temporary switch to CM7_0 core's AP
            __ap = 2;
            // Configure Coresight TF(Trace Funnel)
            reg = Read32(CSTFCTL_Addr);
            reg |= CSTFCTL_Mask;
            Write32(CSTFCTL_Addr, reg);
            // Switch back to CM7_1 core's AP
            __ap = 3;
            // Configure pins
            Sequence("SetupTracePins");
          </block>
        </sequence>
      </sequences>
      <device Dname="CYT4BB5CEE">
        <compile define="CYT4BB5CEE" />
        <feature type="QFP" n="100"/>
        <feature type="Temp" n="-40" m="125"/>
        <feature type="ADC" n="39" m="12"/>
        <feature type="LIN" n="9"/>
        <feature type="I2S" n="2"/>
      </device>
      <device Dname="CYT4BB5CES">
        <compile define="CYT4BB5CES" />
        <feature type="QFP" n="100"/>
        <feature type="Temp" n="-40" m="105"/>
        <feature type="ADC" n="39" m="12"/>
        <feature type="LIN" n="9"/>
        <feature type="I2S" n="2"/>
      </device>
      <device Dname="CYT4BB7CEE">
        <compile define="CYT4BB7CEE" />
        <feature type="QFP" n="144"/>
        <feature type="Temp" n="-40" m="125"/>
        <feature type="ADC" n="54" m="12"/>
        <feature type="LIN" n="12"/>
        <feature type="I2S" n="3"/>
      </device>
      <device Dname="CYT4BB7CES">
        <compile define="CYT4BB7CES" />
        <feature type="QFP" n="144"/>
        <feature type="Temp" n="-40" m="105"/>
        <feature type="ADC" n="54" m="12"/>
        <feature type="LIN" n="12"/>
        <feature type="I2S" n="3"/>
      </device>
      <device Dname="CYT4BB8CEE">
        <compile define="CYT4BB8CEE" />
        <feature type="QFP" n="176"/>
        <feature type="Temp" n="-40" m="125"/>
        <feature type="ADC" n="64" m="12"/>
        <feature type="LIN" n="16"/>
        <feature type="I2S" n="3"/>
      </device>
      <device Dname="CYT4BB8CES">
        <compile define="CYT4BB8CES" />
        <feature type="QFP" n="176"/>
        <feature type="Temp" n="-40" m="105"/>
        <feature type="ADC" n="64" m="12"/>
        <feature type="LIN" n="16"/>
        <feature type="I2S" n="3"/>
      </device>
      <device Dname="CYT4BBBCEE">
        <compile define="CYT4BBBCEE" />
        <feature type="BGA" n="272"/>
        <feature type="Temp" n="-40" m="125"/>
        <feature type="ADC" n="72" m="12"/>
        <feature type="LIN" n="16"/>
        <feature type="I2S" n="3"/>
      </device>
      <device Dname="CYT4BBBCES">
        <compile define="CYT4BBBCES" />
        <feature type="BGA" n="272"/>
        <feature type="Temp" n="-40" m="105"/>
        <feature type="ADC" n="72" m="12"/>
        <feature type="LIN" n="16"/>
        <feature type="I2S" n="3"/>
      </device>
    </subFamily>
    <!-- CYT4BF: 8384KB Flash, Tri-Core -->
    <subFamily DsubFamily="CYT4BF">
      <processor Pname="Cortex-M0p" Dcore="Cortex-M0+" DcoreVersion="r0p1" Dfpu="NO_FPU" Dmpu="MPU" Dendian="Little-endian" Dclock="50000000" />
      <processor Pname="Cortex-M7-0" Dcore="Cortex-M7" DcoreVersion="r1p2" Dfpu="SP_FPU" Dmpu="MPU" Dendian="Little-endian" Dclock="350000000" />
      <processor Pname="Cortex-M7-1" Dcore="Cortex-M7" DcoreVersion="r1p2" Dfpu="SP_FPU" Dmpu="MPU" Dendian="Little-endian" Dclock="350000000" />
      <debug Pname="Cortex-M7-1" svd="Libraries/mtb-pdl-cat1/devices/COMPONENT_CAT1C/svd/cat1c8m.svd" __ap="3" defaultResetSequence="ResetProcessor" />
      <debug Pname="Cortex-M7-0" svd="Libraries/mtb-pdl-cat1/devices/COMPONENT_CAT1C/svd/cat1c8m.svd" __ap="2" defaultResetSequence="ResetProcessor" />
      <debug Pname="Cortex-M0p" svd="Libraries/mtb-pdl-cat1/devices/COMPONENT_CAT1C/svd/cat1c8m.svd" __ap="1" defaultResetSequence="ResetProcessor" />
      <memory name="IRAM1" access="rwx" start="0x28000000" size="0x100000" default="1" />
      <memory name="IROM1" access="rx" start="0x10000000" size="0x830000" default="1" startup="1" />
      <algorithm Pname="Cortex-M0p" name="Flash/CAT1C_8384.FLM" start="0x10000000" size="0x00830000" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M0p" name="Flash/CAT1C_WFLASH_256.FLM" start="0x14000000" size="0x00040000" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M0p" name="Flash/CAT1C_SFLASH_USER.FLM" start="0x17000800" size="0x00000800" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M0p" name="Flash/CAT1C_SFLASH_NAR.FLM" start="0x17001A00" size="0x00000200" RAMstart="0x28001000" RAMsize="0xFFF0" default="0" style="Keil" />
      <algorithm Pname="Cortex-M0p" name="Flash/CAT1C_SFLASH_PKEY.FLM" start="0x17006400" size="0x00000C00" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M0p" name="Flash/CAT1C_SFLASH_TOC2.FLM" start="0x17007C00" size="0x00000200" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M0p" name="Flash/CAT1C_SMIF.FLM" start="0x60000000" size="0x08000000" RAMstart="0x28001000" RAMsize="0xFFF0" default="0" style="Keil" />
      <algorithm Pname="Cortex-M7-0" name="Flash/CAT1C_8384.FLM" start="0x10000000" size="0x00830000" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M7-0" name="Flash/CAT1C_WFLASH_256.FLM" start="0x14000000" size="0x00040000" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M7-0" name="Flash/CAT1C_SFLASH_USER.FLM" start="0x17000800" size="0x00000800" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M7-0" name="Flash/CAT1C_SFLASH_NAR.FLM" start="0x17001A00" size="0x00000200" RAMstart="0x28001000" RAMsize="0xFFF0" default="0" style="Keil" />
      <algorithm Pname="Cortex-M7-0" name="Flash/CAT1C_SFLASH_PKEY.FLM" start="0x17006400" size="0x00000C00" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M7-0" name="Flash/CAT1C_SFLASH_TOC2.FLM" start="0x17007C00" size="0x00000200" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M7-0" name="Flash/CAT1C_SMIF.FLM" start="0x60000000" size="0x08000000" RAMstart="0x28001000" RAMsize="0xFFF0" default="0" style="Keil" />
      <algorithm Pname="Cortex-M7-1" name="Flash/CAT1C_8384.FLM" start="0x10000000" size="0x00830000" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M7-1" name="Flash/CAT1C_WFLASH_256.FLM" start="0x14000000" size="0x00040000" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M7-1" name="Flash/CAT1C_SFLASH_USER.FLM" start="0x17000800" size="0x00000800" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M7-1" name="Flash/CAT1C_SFLASH_NAR.FLM" start="0x17001A00" size="0x00000200" RAMstart="0x28001000" RAMsize="0xFFF0" default="0" style="Keil" />
      <algorithm Pname="Cortex-M7-1" name="Flash/CAT1C_SFLASH_PKEY.FLM" start="0x17006400" size="0x00000C00" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M7-1" name="Flash/CAT1C_SFLASH_TOC2.FLM" start="0x17007C00" size="0x00000200" RAMstart="0x28001000" RAMsize="0xFFF0" default="1" style="Keil" />
      <algorithm Pname="Cortex-M7-1" name="Flash/CAT1C_SMIF.FLM" start="0x60000000" size="0x08000000" RAMstart="0x28001000" RAMsize="0xFFF0" default="0" style="Keil" />
      <book name="https://www.infineon.com/dgdl/Infineon-TRAVEO_T2G_automotive_microcontroller_CYT4BF_32-BIT_Arm_Cortex-M7-DataSheet-v15_00-EN.pdf?fileId=5546d46275b79adb0175dc8387f93228" title="TRAVEO™ T2G CYT4BF Series Data Sheet"/>
      <book name="https://www.infineon.com/sec/login?ret=https%3A%2F%2Fwww.infineon.com%2Fcms%2Fen%2Fproduct%2Fmicrocontroller%2F32-bit-traveo-t2g-arm-cortex-microcontroller%2F32-bit-traveo-t2g-arm-cortex-for-body%2Ftraveo-t2g-cyt4bf-series%2F%23!documents%2Fdocument-group-myInfineon-57" title="TRAVEO™ T2G CYT4BF Series TRM"/>
      <book name="https://www.infineon.com/cms/en/product/microcontroller/32-bit-traveo-t2g-arm-cortex-microcontroller/32-bit-traveo-t2g-arm-cortex-for-body/traveo-t2g-cyt4bf-series/" title="Over view of TRAVEO™ T2G CYT4BF Series"/>
      <debugvars configfile="Debug/cat1c.dbgconf" version="1.0">
        __var __TPIU_pinlocation = 1;                      // Select one of the possible TPIU pin locations
        __var __TPIU_clocksetup = 1;                       // Enable(1) or Disable(0) setup of trace source clock
        __var __TPIU_clockdivval = 0;                      // Clock divider value for trace clock
        // TraceClock configuration data
        __var TRACE_CLOCK_CTL_ADDR = 0x40040C00;           // Clock control register for cpuss.clock_trace_in
        __var TRACE_CLOCK_DIV_CTL_ADDR = 0x40041020;       // Divider control (for 8.0 divider)
        __var TRACE_CLOCK_DIV_CMD_ADDR = 0x40040000;       // Divider command
        __var PERI_CLOCK_CTL_DIV_SEL = 0x03;               // CYT4BF devices have 3 of 8-bit dividers - use the lastest available for tracing
        __var PERI_DIV_PA_SEL_MASK = 0x000003FF;           // PA_TYPE_SEL + PA_DIV_SEL fields mask (size)
        __var PERI_DIV_CMD_PA_SEL_ROL = 0x00000010;        // PA_TYPE_SEL + PA_DIV_SEL fields offset in PERI_DIV_CMD
        // TPIU pins configuration data
        __var hsiomPrt21PortSel0Addr = 0x40300150;  // HSIOM_PRT[port]_PORT_SEL0·register·address. Port 21 selection 0
        __var hsiomPrt22PortSel0Addr = 0x40300160;  // HSIOM_PRT[port]_PORT_SEL0·register·address. Port 22 selection 0
        __var gpioPrt21CfgAddr = 0x40310AC4;        // GPIO_PRT[port]_CFG register address. Port 21 configuration
        __var gpioPrt22CfgAddr = 0x40310B44;        // GPIO_PRT[port]_CFG register address. Port 22 configuration
        __var gpioPrt21CfgOutAddr = 0x40310ACC;     // GPIO_PRT[port]_CFG_OUT register address. Port 21 output buffer configuration
        __var gpioPrt22CfgOutAddr = 0x40310B4C;     // GPIO_PRT[port]_CFG_OUT register address. Port 22 output buffer configuration
      </debugvars>
      <sequences>
        <sequence name="DebugPortStart">
          <block info="Read DP CTRL/STAT">
            __var SW_DP_ABORT  = 0x0;
            __var DP_CTRL_STAT = 0x4;
            __var DP_SELECT    = 0x8;
            __var powered_down = 0;
            // Switch to DP Register Bank 0. Explicitly set APSEL to current AP selection
            WriteDP(DP_SELECT, __ap &lt;&lt; 24);
            // Read DP CTRL/STAT Register and check if CSYSPWRUPACK and CDBGPWRUPACK bits are set
            powered_down = ((ReadDP(DP_CTRL_STAT) &amp; 0xA0000000) != 0xA0000000);
          </block>
          <control if="powered_down">
            <block info="Power Up System &amp; Debug">
              // Request Debug/System Power-Up
              // Ignore error here: even there is a polling in the next block, CMSIS-DAP transports reads DP.RDBUFF register
              // right after write to DP.CTRL_STAT. This will fail for some cases - for example if device is waking from DeepSleep.
              __errorcontrol = 1;
              WriteDP(DP_CTRL_STAT, 0x50000000);
              __errorcontrol = 0;
            </block>
            <!-- Wait for Power-Up Request to be acknowledged -->
            <control while="(ReadDP(DP_CTRL_STAT) &amp; 0xA0000000) != 0xA0000000" timeout="1000000" info="Wait for power acknowledged" />
            <!-- CDBGRSTREQ on CAT1C behaves like Power-On Reset. Not desired when starting the Debug Port
            <block info="Debug Reset">
              __errorcontrol = 1;
              // Request Debug Reset
              WriteDP(DP_CTRL_STAT, 0x54000000);
              // CDBGRSTREQ is equivalent to Power-On Reset and fully reboots the device.
              // Depending on the user application the reboot can take up to 600ms.
              DAP_Delay(600000);
              __errorcontrol = 0;
            </block>
            -->
            <!-- Wait for Debug Reset to be acknowledged, don't issue error on timeout to deal with improperly connected Debug Reset -->
            <!-- <control while="(ReadDP(DP_CTRL_STAT) &amp; 0xA8000000) != 0xA8000000" timeout="300000" info="Wait for Debug Reset Acknowledge"/> -->
            <!-- JTAG Specific Part of sequence -->
            <control if="(__protocol &amp; 0xFFFF) == 1">
              <block info="JTAG: Clear Sticky Bits">
                // Init AP Transfer Mode, Transaction Counter, and Lane Mask (Normal Transfer Mode, Include all Byte Lanes)
                // Additionally clear STICKYORUN, STICKYCMP, and STICKYERR bits by writing '1'
                WriteDP(DP_CTRL_STAT, 0x50000F32);
              </block>
            </control>
            <!-- SWD Specific Part of sequence -->
            <control if="(__protocol &amp; 0xFFFF) == 2">
              <block info="SWD: Init SWD &amp; Clear Sticky Bits">
                // Init AP Transfer Mode, Transaction Counter, and Lane Mask (Normal Transfer Mode, Include all Byte Lanes)
                WriteDP(DP_CTRL_STAT, 0x50000F00);
                // Clear WDATAERR, STICKYORUN, STICKYCMP, and STICKYERR bits of CTRL/STAT Register by write to ABORT register
                WriteDP(SW_DP_ABORT, 0x0000001E);
              </block>
            </control>
          </control>
          <control if="(__connection &amp; 3) == 2">
            <block>
              // Prepare MCU for flash operations
              Sequence("FlashPreparation");
            </block>
          </control>
          <control if="(__connection &amp; 3) == 1">
            <block>
              // Checking core readiness for debugging
              Sequence("DebuggingReadiness");
            </block>
          </control>
          <block>
            // Print device info
            Sequence("PrintDeviceInfo");
          </block>
        </sequence>
        <!-- HW Reset causes a reboot of the device which also resets debug.
             - Using this as a prereset is OK to potentially wake up the system from DeepSleep.
             - Using this in the middle of the debug session will break the connection unless recovery
               from a connection loss is supported by the debug IDE.
        -->
        <sequence name="ResetHardware">
          <block>
            __var nReset      = 0x80;
            __var canReadPins = 0;
            // Deassert nRESET line
            canReadPins = (DAP_SWJ_Pins(0x00, nReset, 0) != 0xFFFFFFFF);
          </block>
          <!-- Keep reset active for 50 ms -->
          <control while="1" timeout="50000" />
          <control if="canReadPins">
            <!-- Assert nRESET line and wait max. 1s for recovery -->
            <control while="(DAP_SWJ_Pins(nReset, nReset, 0) &amp; nReset) == 0" timeout="1000000" />
          </control>
          <control if="!canReadPins">
            <block>
              // Assert nRESET line
              DAP_SWJ_Pins(nReset, nReset, 0);
            </block>
            <!-- Wait 100ms for recovery if nRESET not readable -->
            <control while="1" timeout="100000" />
          </control>
          <block>
            // Give the bootloader time to finish (can be up to 600ms)
            DAP_Delay(600000);
          </block>
        </sequence>
        <sequence name="ResetSystem" Pname="Cortex-M0p">
          <block info="Halt CPU and determine application entry point">
            // System Control Space (SCS) offset as defined in Armv6-M/Armv7-M.
            __var SCS_Addr = 0xE000E000;
            __var AIRCR_Addr = SCS_Addr + 0xD0C;
            __var DHCSR_Addr = SCS_Addr + 0xDF0;
            __var BP_CTRL = 0xE0002000;
            __var BP_COMPx = 0xE0002008;
            __var DP_CTRL_STAT = 0x4;
            __var appValid = 0;
            __var vtBase = 0;
            __var resetAddress = 0;

            // Read VT_BASE register
            vtBase = Read32(0x40201120) &amp; 0xFFFF0000;
            appValid = (vtBase != 0) &amp;&amp; (vtBase != 0xFFFF0000);
          </block>
          <control if="appValid">
            <block info="Set BP at app entry and issue a reset">
              //Get application address at reset vector
              resetAddress = Read32(vtBase + 4);
            </block>
            <control if="(resetAddress != 0) &amp;&amp; (resetAddress != 0xFFFFFFFF)">
              <block>
                // Enable debug, and halt the CPU
                Write32(DHCSR_Addr, 0xA05F0003);

                // Enable Breakpoint unit using the BP_CTRL
                Write32(0xE0002000, 0x00000003);

                // Map the address bits to the breakpoint compare register
                resetAddress = (resetAddress &amp; 0x1FFFFFFC) | 0xC0000001;

                // Update the breakpoint compare register
                Write32(0xE0002008, resetAddress);

                // Issue software reset using the AIRCR (Application Interrupt and Reset
                // Control Register). Note: do not check for ACK_OK of this operation
                __errorcontrol = 1;
                Write32(AIRCR_Addr, 0x05FA0004);
                sequence("DAP_poll");
                __errorcontrol = 0;
              </block>
              <!-- Reset Recovery: Wait for CPUSS_CM0_CTL to  bit to clear on read -->
              <control while="(Read32(DHCSR_Addr) &amp; 0x02000000)" timeout="500000" />
              <block>
                // Enable CM7 core(s) in order to be able to attach to it
                Sequence("DebuggingReadiness");
              </block>
            </control>
          </control>
        </sequence>
        <!-- Cortex-M0+ Processor reset via XMC7xxx CPU Sub-System Controller. Cortex-M0+ doesn't have VECTRESET. -->
        <sequence name="ResetProcessor" Pname="Cortex-M0p">
          <block>
            __var CPUSS_CM0_CTL_Addr = 0x40201000;    // CM0+ Control Register
            __var DHCSR_Addr = 0xE000EDF0;
            Write32(CPUSS_CM0_CTL_Addr, 0x05FA0000);  // Reset CM0+
          </block>
          <!-- Reset Recovery: Wait for CPUSS_CM0_CTL to  bit to clear on read -->
          <control while="(Read32(DHCSR_Addr) &amp; 0x02000000)" timeout="500000" />
        </sequence>
        <!-- Prepare CM0+ core to serve SROM API calls -->
        <sequence name="PrepareCM0">
          <block>
            __var WFI_LOOP_ADDR = 0x28000000 + 0x800;
            __var CM0_SP_ADDR = WFI_LOOP_ADDR + 0x40;
            // Halt CM0+
              Write32(0xE000EDF0, 0xA05F0003);
          </block>
          <control while="(Read32(0xE000EDF0) &amp; 0x00030000) != 0x00030000" timeout="1000000" info="Wait for core halts" />
          <block>
            // Write WFI loop in RAM
            Write32(WFI_LOOP_ADDR, 0xE7FDBF30);
            // Set VECTCLRACTIVE in AIRCR for CM0+
            Write32(0xE000ED0C, 0x05FA0002);
            // Write CM0+ xPSR
            Write32(0xE000EDF8, 0x01000000);
            Write32(0xE000EDF4, 0x00010010);
          </block>
          <control while="(Read32(0xE000EDF0) &amp; 0x00010000) != 0x00010000" timeout="1000000" info="Wait for register transfer to complete" />
          <block>
            // Write CM0+ CONTROL, PRIMASK
            Write32(0xE000EDF8, 0x00000000);
            Write32(0xE000EDF4, 0x00010014);
          </block>
          <control while="(Read32(0xE000EDF0) &amp; 0x00010000) != 0x00010000" timeout="1000000" info="Wait for register transfer to complete" />
          <block>
            // Write CM0+ PC
            Write32(0xE000EDF8, WFI_LOOP_ADDR);
            Write32(0xE000EDF4, 0x0001000F);
          </block>
          <control while="(Read32(0xE000EDF0) &amp; 0x00010000) != 0x00010000" timeout="1000000" info="Wait for register transfer to complete" />
          <block>
            // Write CM0+ SP
            Write32(0xE000EDF8, CM0_SP_ADDR);
            Write32(0xE000EDF4, 0x0001000D);
          </block>
          <control while="(Read32(0xE000EDF0) &amp; 0x00010000) != 0x00010000" timeout="1000000" info="Wait for register transfer to complete" />
          <block>
            // Write CM0+ VTOR
            Write32(0xE000ED08, 0x00000000);
            // Clear all pending interrupts in CM0+
            Write32(0xE000E280, 0x0000FFFF);
            // Enable only CM0+ IRQ0/1
            Write32(0xE000E180, 0xFFFFFFFC);
            Write32(0xE000E100, 0x00000003);
            // Set priority of IRQ0=1, IRQ1=0. Need to make sure IRQ1 is triggered even if IRQ0 is pending.
            Write32(0xE000E400, 0x00000040);
            // Release CM0+ from halt state
            Write32(0xE000EDF0, 0xA05F0001);
          </block>
        </sequence>
        <sequence name="DAP_Handshake">
          <!-- DAP_Handshake: Execute initial handshake sequence depend on selected protocol -->
          <block>
            __var isSWJ      = ((__protocol &amp; 0x00010000) != 0);
            __var protType   = __protocol &amp; 0x0000FFFF;
            __var DPIDR = 0;
            __Result = 0;
          </block>
          <!-- JTAG Protocol -->
          <control if="protType == 1">
            <control if="isSWJ">
              <block atomic="true">
                // Ensure current debug interface is in reset state
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF);
                // Execute SWJ-DP Switch Sequence SWD to JTAG (0xE73C)
                // Change if SWJ-DP uses deprecated switch code (0xAEAE)
                DAP_SWJ_Sequence(16, 0xE73C);
              </block>
            </control>
            <block atomic="true">
              // JTAG "Soft" Reset
              DAP_JTAG_Sequence(6, 1, 0x00);                        // Test-Logic-Reset
              // Get IDCODE to make shure that JTAG-DP is available
              DAP_JTAG_Sequence(4, 0, 0x00);                        // 4*Run-Test/Idle
              DAP_JTAG_Sequence(2, 1, 0x00);                        // ~ Select-DR ~ Select-IR
              DAP_JTAG_Sequence(2, 0, 0x00);                        // ~ Capture-IR ~ Shift-IR
              DAP_JTAG_Sequence(8, 0, 0xFE);                        // Shift-IR (IDCODE BYPASS)
              DAP_JTAG_Sequence(5, 1, 0x00);                        // ~ Exit1-IR (IDCODE BYPASS) ~ Update-IR ~ Test-Logic-Reset
              DAP_JTAG_Sequence(4, 0, 0x00);                        // Make sure that we go through Idle state in TAP controller
              DAP_JTAG_Sequence(1, 1, 0x00);                        // Select-DR
              DAP_JTAG_Sequence(2, 0, 0x00);                        // ~ Capture-DR ~ Shift-DR
              DPIDR = DAP_JTAG_Sequence(33, 0, 0x00000000);         // Shift 33-bits data
              DAP_JTAG_Sequence(5, 1, 0x00);                        // ~ Exit1-DR ~ Update-DR ~ ~ Select-DR ~ Select-IR ~ Test-Logic-Reset
              DAP_JTAG_Sequence(4, 0, 0x00);                        // Make sure that we go through Idle state in TAP controller
            </block>
          </control>
          <!-- SWD Protocol -->
          <control if="protType == 2">
            <control if="isSWJ">
              <block atomic="true">
                // Ensure current debug interface is in reset state
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF);
                // Execute SWJ-DP Switch Sequence JTAG to SWD (0xE79E)
                // Change if SWJ-DP uses deprecated switch code (0xEDB6)
                DAP_SWJ_Sequence(16, 0xE79E);
                // Enter SWD Line Reset State
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // More than 50 cycles SWDIO/TMS High
                DAP_SWJ_Sequence(3,  0x00);               // At least 2 idle cycles (SWDIO/TMS Low)
              </block>
            </control>
            <control if="!isSWJ">
              <block atomic="true">
                // Enter SWD Line Reset State
                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); // More than 50 cycles SWDIO/TMS High
                DAP_SWJ_Sequence(3,  0x00);               // At least 2 idle cycles (SWDIO/TMS Low)
              </block>
            </control>
            <block>
              DPIDR = ReadDP(0x0); // Read DPIDR to enable SWD interface (SW-DPv1 and SW-DPv2)
            </block>
          </control>
          <control if="(DPIDR &amp; 0xFFF00FFF) != 0x6BA00477">
            <block>
              __Result = -1; // DAP is unavailable
            </block>
          </control>
        </sequence>
        <sequence name="DAP_poll">
          <!-- DAP_poll: Poll the DAP until it becomes available -->
          <block>
            __Result = -1; // Assume DAP is not available yet
          </block>
          <control while="__Result != 0" timeout="600000">
            <block>
              sequence("DAP_Handshake"); // Poll DP until bootloader allows access to device (can be up to 600ms)
            </block>
          </control>
          <control if="__Result != 0">
            <block>
              Message(1, "The Debug Access Port is unavailable.");
            </block>
          </control>
        </sequence>
        <!-- Enable CM7 clock -->
        <sequence name="EnableCM7Clock">
          <block>
            __var CLK_ROOT_SELECT = Read32(0x40261244);
          </block>
          <control if="(CLK_ROOT_SELECT &amp; 0x80000000) != 0x80000000">
            <block>
              Write32(0x40261244, (CLK_ROOT_SELECT | 0x80000000));
              Message(0, "CLK_HF1 was enabled.");
            </block>
          </control>
        </sequence>
        <!-- Set power mode of CM7_0 core to ENABLED -->
        <sequence name="PowerUpCM7_0">
          <block>
            __var CM7_PWR_CTL_ADDR = 0x40201200;
            __var CM7_PWR_CTL = Read32(CM7_PWR_CTL_ADDR);
          </block>
          <control if="(CM7_PWR_CTL &amp; 0x3) != 0x3">
            <block>
              // Set power mode of CM7
              Write32(CM7_PWR_CTL_ADDR, 0x05FA0003);
              Message(0, "The power mode of Cortex-M7_0 core was set to ENABLED.");
            </block>
          </control>
          <!-- Set power mode of CM7 to ENABLED. The core will stop at reset vector -->
          <block>
            __var CPUSS_CM7_CTL_ADDR = 0x4020000C;
            __var CPUSS_CM7_CTL = Read32(CPUSS_CM7_CTL_ADDR);
          </block>
          <control if="CPUSS_CM7_CTL &amp; 0x10">
            <block>
              // Deassert CPU_WAIT
              Write32(CPUSS_CM7_CTL_ADDR, (CPUSS_CM7_CTL &amp; 0xFFFFFFEF));
              Message(0, "CPU_WAIT of Cortex-M7_0 core was deasserted.");
            </block>
          </control>
        </sequence>
        <!-- Check CM7 clock -->
        <sequence name="CheckCM7Clock">
          <block>
            __var CLK_ROOT_SELECT = Read32(0x40261244);
          </block>
          <control if="(CLK_ROOT_SELECT &amp; 0x80000000) != 0x80000000">
            <block>
              Message(2, "The CM7 core clock source (CLK_HF1) is not enabled by the CM0+ application. Further debugging is not possible.");
            </block>
          </control>
        </sequence>
        <!-- Check power mode of CM7_0 core  -->
        <sequence name="CheckPowerCM7_0">
          <block>
            __var CM7_PWR_CTL_ADDR = 0x40201200;
            __var CM7_PWR_CTL = Read32(CM7_PWR_CTL_ADDR);
          </block>
          <control if="(CM7_PWR_CTL &amp; 0x3) != 0x3">
            <block>
              Message(2, "The power mode of Cortex-M7_0 core was NOT ENABLED by the CM0+ application. Further debugging is not possible.");
            </block>
          </control>
        </sequence>
        <!-- Read and print device info -->
        <sequence name="PrintDeviceInfo">
          <block>
            __var siId;
            __var siRev;
            __var siFamily;
            __var fbVerHi;
            __var protection;
            __var v;
            Message(0, "****************************************************");
            // Get Si Id, Family and Rev.
            v = Read32(0x17000000);
            siId = (v &amp; 0xFFFF0000) &gt;&gt; 16;
            siRev = (v &amp; 0x0000FF00) &gt;&gt; 8;
            v = Read32(0x1700000C);
            siFamily = v &amp; 0x00000FFF;
            Message(0, "** Silicon: 0x%04X, Family: 0x%03X, Rev.: 0x%02X", siId, siFamily, siRev);
            // Get FlashBboot verison
            fbVerHi = Read32(0x17002004);
          </block>
          <control if="fbVerHi == 0">
            <block>
              Message(1, "Invalid FlashBoot: High version word of Flash Boot is zero");
            </block>
          </control>
          <control if="fbVerHi != 0">
            <block>
              __var fbVerLo = Read32(0x17002018);
              __var b0 = fbVerHi &gt;&gt; 28;
              __var b1 = (fbVerHi &gt;&gt; 24) &amp; 0x0F;
              __var b2 = (fbVerHi &gt;&gt; 16) &amp; 0xFF;
              __var b3 = fbVerHi &amp; 0x0000FFFF;
            </block>
            <control if="b0 &gt; 2">
              <block>
                Message(1, "Unsupported Flash Boot Version - Flash Boot Version [31:28] = 0x%X", b0);
              </block>
            </control>
            <control if="b0 &lt;= 2">
              <control if="b3 != 0x8001">
                <block>
                  Message(1, "Flash Boot is corrupted or non Flash Boot image programmed");
                </block>
              </control>
              <control if="b3 == 0x8001">
                <!-- Versioning scheme #1 -->
                <control if="b0 == 0">
                  <control if="b1 == 1">
                    <block>
                      Message(0, "** Flash Boot version: 1.%02u", b2);
                    </block>
                  </control>
                  <control if="b1 == 2">
                    <control if="b2 &lt; 20">
                      <block>
                        Message(0, "** Flash Boot version: 1.0.0.%u", b2);
                      </block>
                    </control>
                    <control if="(b2 &gt;= 20) &amp;&amp; (b2 &lt; 29)">
                      <block>
                        Message(0, "** Flash Boot version: 1.0.1.%u", b2);
                      </block>
                    </control>
                    <control if="b2 &gt;= 29">
                      <block>
                        Message(0, "** Flash Boot version: 1.20.1.%u", b2);
                      </block>
                    </control>
                  </control>
                </control>
                <!-- Versioning scheme #2 -->
                <control if="b0 == 1">
                  <block>
                    Message(0, "** Flash Boot version: 2.0.0.%u", b2);
                  </block>
                </control>
                <!-- Versioning scheme #3 -->
                <control if="b0 == 2">
                  <block>
                    __var patch = fbVerLo &gt;&gt; 24;
                    __var build = fbVerLo &amp; 0x0000FFFF;
                    Message(0, "** Flash Boot version: %u.%u.%u.%u", b1, b2, patch, build);
                  </block>
                </control>
              </control>
            </control>
          </control>
          <!-- Get life-cycle stage -->
          <control>
            <block>
              protection = Read32(0x402020C4);
            </block>
          </control>
          <!-- Decode life-cycle stage -->
          <control if="protection == 1">
            <block>
              Message(0, "** Chip Protection: VIRGIN");
            </block>
          </control>
          <control if="protection == 2">
            <block>
              Message(0, "** Chip Protection: NORMAL");
            </block>
          </control>
          <control if="protection == 3">
            <block>
              Message(0, "** Chip Protection: SECURE");
            </block>
          </control>
          <control if="protection == 4">
            <block>
              Message(0, "** Chip Protection: DEAD");
            </block>
          </control>
          <control if="(protection == 0) || (protection &gt; 4)">
            <block>
              Message(0, "** Chip Protection: UNKNOWN");
            </block>
          </control>
          <block>
            Message(0, "****************************************************");
          </block>
        </sequence>
        <sequence name="SetupTraceClock">
          <control if="__TPIU_clocksetup != 0">
            <block>
              __var PERI_CLOCK_CTL_DIV_SEL_MASK = 0x0000000F;                    // PERI_CLOCK_CTL.DIV_SEL
              __var PERI_DIV_CMD_ENABLE_MASK = 0x80000000;                       // ENABLE field in PERI_DIV_CMD
              __var PERI_DIV_CMD_DISABLE_MASK = 0x40000000;                      // DISABLE field in PERI_DIV_CMD
              // Peripheral clock divider index to use for trace clock
              __var ClockDivSel = PERI_CLOCK_CTL_DIV_SEL &amp; PERI_CLOCK_CTL_DIV_SEL_MASK;
              __var ClockDivVal = __TPIU_clockdivval &amp; PERI_DIV_PA_SEL_MASK; // Peripheral clock divider value for trace clock
                                                                                 // Actual divider is (1+ClockDivVal)
              __var ClockCtlVal = Read32(TRACE_CLOCK_CTL_ADDR);
              __var ClockDivCtlVal = Read32(TRACE_CLOCK_DIV_CTL_ADDR + (ClockDivSel * 4));
            </block>
            <control if="(ClockCtlVal != ClockDivSel) || (ClockDivCtlVal != ((ClockDivVal &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | 0x1))">
              <block>
                Message(0, "Setup TPIU clock, divider value is %u", ClockDivVal);
                // DISABLE 8.0 DIV in PERI_DIV_CMD:
                __var ClockDivCmd = PERI_DIV_CMD_DISABLE_MASK | (PERI_DIV_PA_SEL_MASK &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | ClockDivSel;
                Write32(TRACE_CLOCK_DIV_CMD_ADDR, ClockDivCmd);
                // Use selected divider (8.0) for cpuss.clock_trace_in
                Write32(TRACE_CLOCK_CTL_ADDR, ClockDivSel);
                // Set 8.0 DIV = ClockDivVal
                Write32((TRACE_CLOCK_DIV_CTL_ADDR + (ClockDivSel * 4)), (ClockDivVal &lt;&lt; 8));
                // ENABLE 8.0 DIV
                ClockDivCmd = PERI_DIV_CMD_ENABLE_MASK | (PERI_DIV_PA_SEL_MASK &lt;&lt; PERI_DIV_CMD_PA_SEL_ROL) | ClockDivSel;
                Write32(TRACE_CLOCK_DIV_CMD_ADDR, ClockDivCmd);
              </block>
            </control>
          </control>
        </sequence>
        <!-- Configure pins trace pins if Parallel Trace Port enabled -->
        <sequence name="SetupTracePins">
          <control if="(__traceout &amp; 0x00000002) != 0" info="Parallel Trace Port enabled">
            <control if="__TPIU_pinlocation == 1" info="XMC72_EVK Kit like">
              <block>
                __var tpWidth = (__traceout &amp; 0x003F0000) &gt;&gt; 16;
                sequence("SetupTracePin_P22_4"); // TRACECLK
                sequence("SetupTracePin_P21_5"); // TRACEDATA[0]
              </block>
              <control if="tpWidth &gt; 1">
                <block>
                  sequence("SetupTracePin_P22_1"); // TRACEDATA[1]
                </block>
              </control>
              <control if="tpWidth &gt; 2">
                <block>
                  sequence("SetupTracePin_P22_2"); // TRACEDATA[2]
                  sequence("SetupTracePin_P22_3"); // TRACEDATA[3]
                </block>
              </control>
            </control>
          </control>
        </sequence>
        <!-- Setup Trace Pin 21_5 as TRACEDATA[0]  -->
        <sequence name="SetupTracePin_P21_5">
          <block>
            __var pin = 5;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P21_5)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt21PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt21PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt21CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt21CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt21CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt21CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[0] to P21_5");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P22_1 as TRACEDATA[1] -->
        <sequence name="SetupTracePin_P22_1">
          <block>
            __var pin = 1;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P22_1)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt22PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt22PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt22CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt22CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt22CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt22CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[1] to P22_1");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P22_2 as TRACEDATA[2] -->
        <sequence name="SetupTracePin_P22_2">
          <block>
            __var pin = 2;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P22_2)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt22PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt22PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt22CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt22CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt22CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt22CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[2] to P22_2");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P22_3 as TRACEDATA[3] -->
        <sequence name="SetupTracePin_P22_3">
          <block>
            __var pin = 3;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_data[0-3]' signals (P22_3)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt22PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt22PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt22CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt22CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt22CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt22CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACEDATA[3] to P22_3");
            </block>
          </control>
        </sequence>
        <!-- Setup Trace Pin P22_4 as TRACECLK -->
        <sequence name="SetupTracePin_P22_4">
          <block>
            __var pin = 4;                            // Pin number
            __var ioSelVal = 0x1B;                    // IO[pin]_SEL field value (connection) for HSIOM_PRT[port]_PORT_SEL register. Connection route for 'cpuss.trace_clock' signal (P22_4)
            __var reg0;
            __var reg1;
            __var offset;
            __var hsiomRegAddr; // Address of HSIOM_PRT[port]_PORT_SEL0 or HSIOM_PRT[port]_PORT_SEL1
            __var pMode = 6;  // pin drive mode
                              //  0: HIGHZ:         Output buffer is off creating a high impedance input (default)
                              //  1: RESERVED:      This mode is reserved and should not be used
                              //  2: PULLUP:        Resistive pull up
                              //  3: PULLDOWN:      Resistive pull down
                              //  4: OD_DRIVESLOW:  Open drain, drives low
                              //  5: OD_DRIVESHIGH: Open drain, drives high
                              //  6: STRONG:        Strong D_OUTput buffer
                              //  7: PULLUP_DOWN:   Pull up or pull down
            __var pSlew = 0;  // pin slew rate
                              //  0 - Fast slew rate (default)
                              //  1 - Slow slew rate
            __var pStrange = 2;   // pin drive strange
                                  //  0 - FULL_DRIVE:        Full drive strength: GPIO drives current at its max rated spec.
                                  //  1 - ONE_HALF_DRIVE:    1/2 drive strength: GPIO drives current at 1/2 of its max rated spec (default)
                                  //  2 - ONE_QUARTER_DRIVE: 1/4 drive strength: GPIO drives current at 1/4 of its max rated spec.
                                  //  3 - ONE_EIGHTH_DRIVE:  1/8 drive strength: GPIO drives current at 1/8 of its max rated spec.
            __var confChanged = 0; // Pin's configuration change flag
            __var PRT_IO_SEL_MASK = 0x1F;    // Mask for IO[pin]_SEL field in HSIOM_PRT[port]_PORT_SEL[0/1] register
            __var PRT_DRIVE_MODE_MASK = 0xF; // Mask for IN_EN[pin] and DRIVE_MODE[pin] fields in GPIO_PRT[port]_CFG register
            __var PRT_SLOW_MASK = 0x1;       // Mask for SLOW[pin] field in GPIO_PRT[port]_CFG_OUT register
            __var PRT_DRIVE_SEL_MASK = 0x3;  // Mask for DRIVE_SEL[pin] field in GPIO_PRT[port]_CFG_OUT register
          </block>
          <!-- Select pin route connection in HSIOM_PRT[port]_PORT_SEL[0/1] register -->
          <control if="pin &lt; 4">
            <block>
              // Pin[0-3] selection is in HSIOM_PRT[port]_PORT_SEL0 register
              hsiomRegAddr = hsiomPrt22PortSel0Addr; // Use HSIOM_PRT[port]_PORT_SEL0
              offset = pin * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <control if="pin &gt; 3">
            <block>
              // Pin[4-7] selection is in HSIOM_PRT[port]_PORT_SEL1 register
              hsiomRegAddr = hsiomPrt22PortSel0Addr + 4; // Use HSIOM_PRT[port]_PORT_SEL1
              offset = (pin &amp; 3) * 8; // Offset of the IO[pin]_SEL field for required pin number,
                                      // where 8 = 5 bits for IO[pin]_SEL field + 3 not used bits
            </block>
          </control>
          <block>
            reg0 = Read32(hsiomRegAddr);
            reg1 = (reg0 &amp; ~(PRT_IO_SEL_MASK &lt;&lt; offset)) | (ioSelVal &lt;&lt; offset); // Update value in IO[pin]_SEL field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(hsiomRegAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Disable input buffer and set drive mode in GPIO_PRT[port]_CFG register -->
          <block>
            reg0 = Read32(gpioPrt22CfgAddr);
            offset = pin * 4;   // Offset of the DRIVE_MODE[pin] field for required pin number,
                                // where 4 = 3 bits for DRIVE_MODE[pin] + 1 bit for IN_EN fields
            reg1 = (reg0 &amp; ~(PRT_DRIVE_MODE_MASK &lt;&lt; offset)) | (pMode &lt;&lt; offset); // Update value in IN_EN[pin] and DRIVE_MODE[pin] fields
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt22CfgAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <!-- Set slew rate and drive strength in GPIO_PRT[port]_CFG_OUT register -->
          <block>
            reg0 = Read32(gpioPrt22CfgOutAddr);
            offset = pin;
            reg1 = (reg0 &amp; ~(PRT_SLOW_MASK &lt;&lt; offset)) | (pSlew &lt;&lt; offset); // Update value in SLOW[pin] field
            offset = 16 + pin * 2; // Offset of the DRIVE_SEL[pin] field for required pin number,
                                   // where '16' is the offset of DRIVE_SEL[pin] for pin 0 and '2' is the size of DRIVE_SEL[pin]
            reg1 = (reg1 &amp; ~(PRT_DRIVE_SEL_MASK &lt;&lt; offset)) | (pStrange &lt;&lt; offset); // Update value in DRIVE_SEL[pin] field
          </block>
          <control if="reg0 |= reg1">
            <block>
              Write32(gpioPrt22CfgOutAddr, reg1);
              confChanged = 1;
            </block>
          </control>
          <control if="confChanged |= 0">
            <block>
              Message(0, "Set TRACECLK to P22_4");
            </block>
          </control>
        </sequence>
        <!-- Set power mode of CM7_1 core to ENABLED -->
        <sequence name="PowerUpCM7_1">
          <block>
            __var CM7_PWR_CTL_ADDR = 0x40201210;
            __var CM7_PWR_CTL = Read32(CM7_PWR_CTL_ADDR);
          </block>
          <control if="(CM7_PWR_CTL &amp; 0x3) != 0x3">
            <block>
              // Set power mode of CM7
              Write32(CM7_PWR_CTL_ADDR, 0x05FA0003);
              Message(0, "The power mode of Cortex-M7_1 core was set to ENABLED.");
            </block>
          </control>
          <!-- Set power mode of CM7 to ENABLED. The core will stop at reset vector -->
          <block>
            __var CPUSS_CM7_CTL_ADDR = 0x4020040C;
            __var CPUSS_CM7_CTL = Read32(CPUSS_CM7_CTL_ADDR);
          </block>
          <control if="CPUSS_CM7_CTL &amp; 0x10">
            <block>
              // Deassert CPU_WAIT
              Write32(CPUSS_CM7_CTL_ADDR, (CPUSS_CM7_CTL &amp; 0xFFFFFFEF));
              Message(0, "CPU_WAIT of Cortex-M7_1 core was deasserted.");
            </block>
          </control>
        </sequence>
        <!-- Make required steps for flash operations -->
        <sequence name="FlashPreparation">
          <control if="__ap == 2">
            <block>
              // Use CM0+ ap for nested sequences
              __ap = 1;
              Sequence("PrepareCM0");
              Sequence("EnableCM7Clock");
              Sequence("PowerUpCM7_0");
            </block>
          </control>
          <control if="__ap == 3">
            <block>
              // Use CM0+ ap for nested sequences
              __ap = 1;
              Sequence("PrepareCM0");
              Sequence("EnableCM7Clock");
              Sequence("PowerUpCM7_1");
            </block>
          </control>
        </sequence>
        <!-- Check power mode of CM7_1 core  -->
        <sequence name="CheckPowerCM7_1">
          <block>
            __var CM7_PWR_CTL_ADDR = 0x40201210;
            __var CM7_PWR_CTL = Read32(CM7_PWR_CTL_ADDR);
          </block>
          <control if="(CM7_PWR_CTL &amp; 0x3) != 0x3">
            <block>
              Message(2, "The power mode of Cortex-M7_1 core was NOT ENABLED by the CM0+ application. Further debugging is not possible.");
            </block>
          </control>
        </sequence>
        <!-- Make sure that the application on CM0+ has prepared the CM7 core for debugging.  -->
        <sequence name="DebuggingReadiness">
          <control if="__ap == 1">
            <block>
              Sequence("EnableCM7Clock");
              Sequence("PowerUpCM7_0");
              Sequence("PowerUpCM7_1");
            </block>
          </control>
          <control if="__ap == 2">
            <block>
              // Use CM0+ ap for nested sequences
              __ap = 1;
              Sequence("CheckCM7Clock");
              Sequence("CheckPowerCM7_0");
            </block>
          </control>
          <control if="__ap == 3">
            <block>
              // Use CM0+ ap for nested sequences
              __ap = 1;
              Sequence("CheckCM7Clock");
              Sequence("CheckPowerCM7_1");
            </block>
          </control>
        </sequence>
        <sequence name="DebugCoreStart" Pname="Cortex-M7-0">
          <block>
            // System Control Space (SCS) offset as defined in Armv6-M/Armv7-M.
            __var SCS_Addr   = 0xE000E000;
            __var DHCSR_Addr = SCS_Addr + 0xDF0;
            // Enable Core Debug via DHCSR
            Write32(DHCSR_Addr, 0xA05F0001);
          </block>
          <!-- Enable clock to ETM block for proper ETM detection if Parallel Trace Port enabled and it is Debug session -->
          <control if="((__connection &amp; 0x00000001) != 0) &amp;&amp; ((__traceout &amp; 0x00000002) != 0)">
            <block>
              Sequence("SetupTraceClock");
            </block>
          </control>
        </sequence>
        <sequence name="DebugCoreStart" Pname="Cortex-M7-1">
          <block>
            // System Control Space (SCS) offset as defined in Armv6-M/Armv7-M.
            __var SCS_Addr   = 0xE000E000;
            __var DHCSR_Addr = SCS_Addr + 0xDF0;
            // Enable Core Debug via DHCSR
            Write32(DHCSR_Addr, 0xA05F0001);
          </block>
          <!-- Enable clock to ETM block for proper ETM detection if Parallel Trace Port enabled and it is Debug session -->
          <control if="((__connection &amp; 0x00000001) != 0) &amp;&amp; ((__traceout &amp; 0x00000002) != 0)">
            <block>
              Sequence("SetupTraceClock");
            </block>
          </control>
        </sequence>
        <!-- Configure trace clock and pins -->
        <sequence name="TraceStart" Pname="Cortex-M7-0">
          <block>
            __var CSTFCTL_Addr = 0xE008C000;
            __var CSTFCTL_Mask = 0x00000003; // Enable slave ports #0 and #1 mask for CM7_0 core
            __var reg;
            // Configure Coresight TF(Trace Funnel)
            reg = Read32(CSTFCTL_Addr);
            reg |= CSTFCTL_Mask;
            Write32(CSTFCTL_Addr, reg);
            // Configure pins
            Sequence("SetupTracePins");
          </block>
        </sequence>
        <sequence name="TraceStart" Pname="Cortex-M7-1">
          <block>
            __var CSTFCTL_Addr = 0xE008C000;
            __var CSTFCTL_Mask = 0x0000000C; // Enable slave ports #2 and #3 mask for CM7_1 core
            __var reg;
            // Temporary switch to CM7_0 core's AP
            __ap = 2;
            // Configure Coresight TF(Trace Funnel)
            reg = Read32(CSTFCTL_Addr);
            reg |= CSTFCTL_Mask;
            Write32(CSTFCTL_Addr, reg);
            // Switch back to CM7_1 core's AP
            __ap = 3;
            // Configure pins
            Sequence("SetupTracePins");
          </block>
        </sequence>
      </sequences>
       <device Dname="CYT4BF8CDE">
        <compile Pname="Cortex-M0p" define="CYT4BF8CDE" />
        <compile Pname="Cortex-M7-0" Pdefine="CORE_NAME_CM7_0" define="CYT4BF8CDE" />
        <compile Pname="Cortex-M7-1" Pdefine="CORE_NAME_CM7_1" define="CYT4BF8CDE" />
        <feature type="QFP" n="176"/>
        <feature type="Temp" n="-40" m="125"/>
        <feature type="ADC" n="81" m="12"/>
        <feature type="LIN" n="17"/>
      </device>
      <device Dname="CYT4BF8CDS">
        <compile Pname="Cortex-M0p" define="CYT4BF8CDS" />
        <compile Pname="Cortex-M7-0" Pdefine="CORE_NAME_CM7_0" define="CYT4BF8CDS"/>
        <compile Pname="Cortex-M7-1" Pdefine="CORE_NAME_CM7_1" define="CYT4BF8CDS"/>
        <feature type="QFP" n="176"/>
        <feature type="Temp" n="-40" m="105"/>
        <feature type="ADC" n="81" m="12"/>
        <feature type="LIN" n="17"/>
      </device>
      <device Dname="CYT4BF8CEE">
        <compile Pname="Cortex-M0p" define="CYT4BF8CEE" />
        <compile Pname="Cortex-M7-0" Pdefine="CORE_NAME_CM7_0" define="CYT4BF8CEE" />
        <compile Pname="Cortex-M7-1" Pdefine="CORE_NAME_CM7_1" define="CYT4BF8CEE" />
        <feature type="QFP" n="176"/>
        <feature type="Temp" n="-40" m="125"/>
        <feature type="ADC" n="81" m="12"/>
        <feature type="LIN" n="17"/>
      </device>
      <device Dname="CYT4BF8CES">
        <compile Pname="Cortex-M0p" define="CYT4BF8CES" />
        <compile Pname="Cortex-M7-0" Pdefine="CORE_NAME_CM7_0" define="CYT4BF8CES" />
        <compile Pname="Cortex-M7-1" Pdefine="CORE_NAME_CM7_1" define="CYT4BF8CES" />
        <feature type="QFP" n="176"/>
        <feature type="Temp" n="-40" m="105"/>
        <feature type="ADC" n="81" m="12"/>
        <feature type="LIN" n="17"/>
      </device>
      <device Dname="CYT4BFBCHE">
        <compile Pname="Cortex-M0p" define="CYT4BFBCHE" />
        <compile Pname="Cortex-M7-0" Pdefine="CORE_NAME_CM7_0" define="CYT4BFBCHE" />
        <compile Pname="Cortex-M7-1" Pdefine="CORE_NAME_CM7_1" define="CYT4BFBCHE" />
        <feature type="BGA" n="272"/>
        <feature type="Temp" n="-40" m="125"/>
        <feature type="ADC" n="96" m="12"/>
        <feature type="LIN" n="20"/>
      </device>
      <device Dname="CYT4BFBCHS">
        <compile Pname="Cortex-M0p" define="CYT4BFBCHS" />
        <compile Pname="Cortex-M7-0" Pdefine="CORE_NAME_CM7_0" define="CYT4BFBCHS" />
        <compile Pname="Cortex-M7-1" Pdefine="CORE_NAME_CM7_1" define="CYT4BFBCHS" />
         <feature type="BGA" n="272"/>
        <feature type="Temp" n="-40" m="105"/>
        <feature type="ADC" n="96" m="12"/>
        <feature type="LIN" n="20"/>
      </device>
      <device Dname="CYT4BFBCJE">
        <compile Pname="Cortex-M0p" define="CYT4BFBCJE" />
        <compile Pname="Cortex-M7-0" Pdefine="CORE_NAME_CM7_0" define="CYT4BFBCJE" />
        <compile Pname="Cortex-M7-1" Pdefine="CORE_NAME_CM7_1" define="CYT4BFBCJE" />
        <feature type="BGA" n="272"/>
        <feature type="Temp" n="-40" m="125"/>
        <feature type="ADC" n="96" m="12"/>
        <feature type="LIN" n="20"/>
      </device>
      <device Dname="CYT4BFBCJS">
        <compile Pname="Cortex-M0p" define="CYT4BFBCJS" />
        <compile Pname="Cortex-M7-0" Pdefine="CORE_NAME_CM7_0" define="CYT4BFBCJS" />
        <compile Pname="Cortex-M7-1" Pdefine="CORE_NAME_CM7_1" define="CYT4BFBCJS" />
        <feature type="BGA" n="272"/>
        <feature type="Temp" n="-40" m="105"/>
        <feature type="ADC" n="96" m="12"/>
        <feature type="LIN" n="20"/>
      </device>
      <device Dname="CYT4BFCCHE">
        <compile Pname="Cortex-M0p" define="CYT4BFCCHE" />
        <compile Pname="Cortex-M7-0" Pdefine="CORE_NAME_CM7_0" define="CYT4BFCCHE" />
        <compile Pname="Cortex-M7-1" Pdefine="CORE_NAME_CM7_1" define="CYT4BFCCHE" />
        <feature type="BGA" n="320"/>
        <feature type="Temp" n="-40" m="125"/>
        <feature type="ADC" n="96" m="12"/>
        <feature type="LIN" n="20"/>
      </device>
      <device Dname="CYT4BFCCHS">
        <compile Pname="Cortex-M0p" define="CYT4BFCCHS" />
        <compile Pname="Cortex-M7-0" Pdefine="CORE_NAME_CM7_0" define="CYT4BFCCHS" />
        <compile Pname="Cortex-M7-1" Pdefine="CORE_NAME_CM7_1" define="CYT4BFCCHS" />
        <feature type="BGA" n="320"/>
        <feature type="Temp" n="-40" m="125"/>
        <feature type="ADC" n="96" m="12"/>
        <feature type="LIN" n="20"/>
      </device>
      <device Dname="CYT4BFCCJE">
        <compile Pname="Cortex-M0p" define="CYT4BFCCJE" />
        <compile Pname="Cortex-M7-0" Pdefine="CORE_NAME_CM7_0" define="CYT4BFCCJE" />
        <compile Pname="Cortex-M7-1" Pdefine="CORE_NAME_CM7_1" define="CYT4BFCCJE" />
        <feature type="BGA" n="320"/>
        <feature type="Temp" n="-40" m="125"/>
        <feature type="ADC" n="96" m="12"/>
        <feature type="LIN" n="20"/>
      </device>
      <device Dname="CYT4BFCCJS">
        <compile Pname="Cortex-M0p" define="CYT4BFCCJS" />
        <compile Pname="Cortex-M7-0" Pdefine="CORE_NAME_CM7_0" define="CYT4BFCCJS" />
        <compile Pname="Cortex-M7-1" Pdefine="CORE_NAME_CM7_1" define="CYT4BFCCJS" />
        <feature type="BGA" n="320"/>
        <feature type="Temp" n="-40" m="105"/>
        <feature type="ADC" n="96" m="12"/>
        <feature type="LIN" n="20"/>
      </device>
    </subFamily>
  </family>
</devices>

<conditions>
  <!-- Compiler Conditions -->
  <condition id="ARMCC">
    <require Tcompiler="ARMCC"/>
  </condition>
  <condition id="GCC">
    <require Tcompiler="GCC"/>
  </condition>
  <condition id="IAR">
    <require Tcompiler="IAR"/>
  </condition>

  <condition id="CYT3BB">
    <description>Infineon CYT3BB Series devices</description>
    <require Dvendor="Infineon:7" Dname="CYT3BB*"/>
  </condition>

  <condition id="CYT3BB_GCC">
    <description>Infineon CYT3BB Series devices compiled using GCC</description>
    <require condition="CYT3BB"/>
    <require condition="GCC"/>
  </condition>

  <condition id="CYT3BB_ARMCC">
    <description>Infineon CYT3BB Series devices compiled using ARMCC</description>
    <require condition="CYT3BB"/>
    <require condition="ARMCC"/>
  </condition>

  <condition id="CYT3BB_IAR">
    <description>Infineon CYT3BB Series devices compiled using IAR</description>
    <require condition="CYT3BB"/>
    <require condition="IAR"/>
  </condition>

  <condition id="CYT4BB">
    <description>Infineon CYT4BB Series devices</description>
    <require Dvendor="Infineon:7" Dname="CYT4BB*"/>
  </condition>

  <condition id="CYT4BB_GCC">
    <description>Infineon CYT4BB Series devices compiled using GCC</description>
    <require condition="CYT4BB"/>
    <require condition="GCC"/>
  </condition>

  <condition id="CYT4BB_ARMCC">
    <description>Infineon CYT4BB Series devices compiled using ARMCC</description>
    <require condition="CYT4BB"/>
    <require condition="ARMCC"/>
  </condition>

  <condition id="CYT4BB_IAR">
    <description>Infineon CYT4BB Series devices compiled using IAR</description>
    <require condition="CYT4BB"/>
    <require condition="IAR"/>
  </condition>

  <condition id="CYT4BF">
    <description>Infineon CYT4BF Series devices</description>
    <require Dvendor="Infineon:7" Dname="CYT4BF*"/>
  </condition>

  <condition id="CYT4BF_GCC">
    <description>Infineon CYT4BF Series devices compiled using GCC</description>
    <require condition="CYT4BF"/>
    <require condition="GCC"/>
  </condition>

  <condition id="CYT4BF_ARMCC">
    <description>Infineon CYT4BF Series devices compiled using ARMCC</description>
    <require condition="CYT4BF"/>
    <require condition="ARMCC"/>
  </condition>

  <condition id="CYT4BF_IAR">
    <description>Infineon CYT4BF Series devices compiled using IAR</description>
    <require condition="CYT4BF"/>
    <require condition="IAR"/>
  </condition>

  <condition id="CM0P">
    <description>Infineon CYT4BF Series devices CM0P</description>
    <accept condition="CYT4BF"/>
    <accept condition="CYT4BB"/>
    <accept condition="CYT3BB"/>
    <require Dcore="Cortex-M0+"/>
  </condition>

  <condition id="CM7">
    <description>Infineon CYT4BF Series devices CM7</description>
    <accept condition="CYT4BF"/>
    <accept condition="CYT4BB"/>
    <accept condition="CYT3BB"/>
    <require Dcore="Cortex-M7"/>
  </condition>

  <condition id="CMSIS">
    <description>Infineon CYT4BF Series devices and CMSIS-CORE</description>
    <accept condition="CM0P"/>
    <accept condition="CM7"/>
    <require Cclass="CMSIS" Cgroup="CORE"/>
  </condition>

  <condition id="CM0P CMSIS">
    <description>Infineon CYT4BF Series devices CM0P and CMSIS-CORE</description>
    <require condition="CM0P"/>
    <require Cclass="CMSIS" Cgroup="CORE"/>
    <require Cclass="Device" Cgroup="Peripheral Driver Library" Csub="PDL"/>
  </condition>

  <condition id="CM7 CMSIS">
    <description>Infineon CYT4BF Series devices CM7 and CMSIS-CORE</description>
    <require condition="CM7"/>
    <require Cclass="CMSIS" Cgroup="CORE"/>
    <require Cclass="Device" Cgroup="Peripheral Driver Library" Csub="PDL"/>
  </condition>

  <condition id="CM7_0 AC6 LINKER">
    <description>Core Specific macro for CM7_0 - AC6 </description>
    <require condition="CM7"/>
    <require condition="CYT4BF_ARMCC"/>
    <require Dname="CYT4BF*" Pname="Cortex-M7-0"/>
  </condition>

  <condition id="CM7_1 AC6 LINKER">
    <description>Core Specific macro for CM7_1 - AC6 </description>
    <require condition="CM7"/>
    <require condition="CYT4BF_ARMCC"/>
    <require Dname="CYT4BF*" Pname="Cortex-M7-1"/>
  </condition>

  <condition id="CM7_0 GCC LINKER">
    <description>Core Specific macro for CM7_0 - AC6 </description>
    <require condition="CM7"/>
    <require condition="CYT4BF_GCC"/>
    <require Dname="CYT4BF*" Pname="Cortex-M7-0"/>
  </condition>

  <condition id="CM7_1 GCC LINKER">
    <description>Core Specific macro for CM7_1 - AC6 </description>
    <require condition="CM7"/>
    <require condition="CYT4BF_GCC"/>
    <require Dname="CYT4BF*" Pname="Cortex-M7-1"/>
  </condition>

  <condition id="CM7_0 IAR LINKER">
    <description>Core Specific macro for CM7_0 - AC6 </description>
    <require condition="CM7"/>
    <require condition="CYT4BF_IAR"/>
    <require Dname="CYT4BF*" Pname="Cortex-M7-0"/>
  </condition>

  <condition id="CM7_1 IAR LINKER">
    <description>Core Specific macro for CM7_1 - AC6 </description>
    <require condition="CM7"/>
    <require condition="CYT4BF_IAR"/>
    <require Dname="CYT4BF*" Pname="Cortex-M7-1"/>
  </condition>

</conditions>

<components>
  <component Cclass="Device" Cgroup="Startup" condition="CM0P CMSIS" Cversion="1.0.0">
    <description>Cortex-M0+ System Startup for Infineon Traveo T2G Series</description>
    <RTE_Components_h>  <!-- the following content goes into file 'RTE_Components.h' -->
      #define CMSIS_device_header "cy_device.h"
    </RTE_Components_h>
    <files>
      <file category="include"       name="Libraries/core-lib/include/"/>
      <file category="include"       name="Libraries/mtb-pdl-cat1/devices/COMPONENT_CAT1C/include/"/>
      <file category="include"       name="Libraries/mtb-pdl-cat1/drivers/include/"/>
      <file category="include"       name="Libraries/mtb-pdl-cat1/devices/COMPONENT_CAT1C/include/"/>
      <file category="source"        name="Libraries/mtb-pdl-cat1/devices/COMPONENT_CAT1C/source/cy_device.c" version="1.0.0"/>
      <file category="include"       name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/"/>
      <file category="include"       name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/HEADER_FILES/"/>
      <file category="source"        name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM0P/system_cm0plus.c"  attr="config" version="2.1.0"/>
      <file category="source"        name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM0P/TOOLCHAIN_GCC_ARM/startup_cm0plus_gcc.S"  attr="config" version="1.0.0" condition="CYT3BB_GCC"/>
      <file category="source"        name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM0P/TOOLCHAIN_ARM/startup_cm0plus_armcc.s"  attr="config" version="1.0.0" condition="CYT3BB_ARMCC"/>
      <file category="source"        name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM0P/TOOLCHAIN_IAR/startup_cm0plus_iar.s"  attr="config" version="1.0.0" condition="CYT3BB_IAR"/>
      <file category="linkerScript"  name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM0P/TOOLCHAIN_GCC_ARM/xmc7100_x4160_cm0plus.ld"  attr="config" version="1.0.0" condition="CYT3BB_GCC"/>
      <file category="linkerScript"  name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM0P/TOOLCHAIN_ARM/xmc7100_x4160_cm0plus.sct"  attr="config" version="1.0.0" condition="CYT3BB_ARMCC"/>
      <file category="linkerScript"  name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM0P/TOOLCHAIN_IAR/xmc7100_x4160_cm0plus.icf"  attr="config" version="1.0.0" condition="CYT3BB_IAR"/>
      <file category="source"        name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM0P/TOOLCHAIN_GCC_ARM/startup_cm0plus_gcc.S"  attr="config" version="1.0.0" condition="CYT4BB_GCC"/>
      <file category="source"        name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM0P/TOOLCHAIN_ARM/startup_cm0plus_armcc.s"  attr="config" version="1.0.0" condition="CYT4BB_ARMCC"/>
      <file category="source"        name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM0P/TOOLCHAIN_IAR/startup_cm0plus_iar.s"  attr="config" version="1.0.0" condition="CYT4BB_IAR"/>
      <file category="linkerScript"  name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM0P/TOOLCHAIN_GCC_ARM/xmc7100d_x4160_cm0plus.ld"  attr="config" version="1.0.0" condition="CYT4BB_GCC"/>
      <file category="linkerScript"  name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM0P/TOOLCHAIN_ARM/xmc7100d_x4160_cm0plus.sct"  attr="config" version="1.0.0" condition="CYT4BB_ARMCC"/>
      <file category="linkerScript"  name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM0P/TOOLCHAIN_IAR/xmc7100d_x4160_cm0plus.icf"  attr="config" version="1.0.0" condition="CYT4BB_IAR"/>
      <file category="source"        name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM0P/TOOLCHAIN_GCC_ARM/startup_cm0plus_gcc.S"  attr="config" version="1.0.0" condition="CYT4BF_GCC"/>
      <file category="source"        name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM0P/TOOLCHAIN_ARM/startup_cm0plus_armcc.s"  attr="config" version="1.0.0" condition="CYT4BF_ARMCC"/>
      <file category="source"        name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM0P/TOOLCHAIN_IAR/startup_cm0plus_iar.s"  attr="config" version="1.0.0" condition="CYT4BF_IAR"/>
      <file category="linkerScript"  name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM0P/TOOLCHAIN_GCC_ARM/xmc7200d_x8384_cm0plus.ld"  attr="config" version="1.0.0" condition="CYT4BF_GCC"/>
      <file category="linkerScript"  name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM0P/TOOLCHAIN_ARM/xmc7200d_x8384_cm0plus.sct"  attr="config" version="1.0.0" condition="CYT4BF_ARMCC"/>
      <file category="linkerScript"  name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM0P/TOOLCHAIN_IAR/xmc7200d_x8384_cm0plus.icf"  attr="config" version="1.0.0" condition="CYT4BF_IAR"/>
    </files>
  </component>

  <component Cclass="Device" Cgroup="Startup" condition="CM7 CMSIS" Cversion="1.0.0">
    <description>Cortex-M4 System Startup for Infineon Traveo T2G Series</description>
    <RTE_Components_h>  <!-- the following content goes into file 'RTE_Components.h' -->
      #define CMSIS_device_header "cy_device.h"
    </RTE_Components_h>
    <files>
      <file category="include"       name="Libraries/core-lib/include/"/>
      <file category="include"       name="Libraries/mtb-pdl-cat1/devices/COMPONENT_CAT1C/include/"/>
      <file category="include"       name="Libraries/mtb-pdl-cat1/drivers/include/"/>
      <file category="include"       name="Libraries/mtb-pdl-cat1/devices/COMPONENT_CAT1C/include/"/>
      <file category="source"        name="Libraries/mtb-pdl-cat1/devices/COMPONENT_CAT1C/source/cy_device.c" version="1.0.0"/>
      <file category="include"       name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/"/>
      <file category="include"       name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/HEADER_FILES/"/>
      <file category="source"        name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM7/system_cm7.c"  attr="config" version="2.1.0"/>
      <file category="source"        name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM7/startup_cm7.c"  attr="config" version="2.1.0"/>
      <file category="linkerScript"  name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM7/TOOLCHAIN_GCC_ARM/xmc7100_x4160_cm7.ld"  attr="config" version="1.0.0" condition="CYT3BB_GCC"/>
      <file category="linkerScript"  name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM7/TOOLCHAIN_ARM/xmc7100_x4160_cm7.sct"  attr="config" version="1.0.0" condition="CYT3BB_ARMCC"/>
      <file category="linkerScript"  name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM7/TOOLCHAIN_IAR/xmc7100_x4160_cm7.icf"  attr="config" version="1.0.0" condition="CYT3BB_IAR"/>
      <file category="linkerScript"  name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM7/TOOLCHAIN_GCC_ARM/xmc7100d_x4160_cm7.ld"  attr="config" version="1.0.0" condition="CYT4BB_GCC"/>
      <file category="linkerScript"  name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM7/TOOLCHAIN_ARM/xmc7100d_x4160_cm7.sct"  attr="config" version="1.0.0" condition="CYT4BB_ARMCC"/>
      <file category="linkerScript"  name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM7/TOOLCHAIN_IAR/xmc7100d_x4160_cm7.icf"  attr="config" version="1.0.0" condition="CYT4BB_IAR"/>
      <file category="linkerScript"  name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM7/TOOLCHAIN_GCC_ARM/xmc7200d_x8384_cm7_0.ld"  attr="config" version="1.0.0" condition="CM7_0 GCC LINKER"/>
      <file category="linkerScript"  name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM7/TOOLCHAIN_GCC_ARM/xmc7200d_x8384_cm7_1.ld"  attr="config" version="1.0.0" condition="CM7_1 GCC LINKER"/>
      <file category="linkerScript"  name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM7/TOOLCHAIN_ARM/xmc7200d_x8384_cm7_0.sct"  attr="config" version="1.0.0" condition="CM7_0 AC6 LINKER"/>
      <file category="linkerScript"  name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM7/TOOLCHAIN_ARM/xmc7200d_x8384_cm7_1.sct"  attr="config" version="1.0.0" condition="CM7_1 AC6 LINKER"/>
      <file category="linkerScript"  name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM7/TOOLCHAIN_IAR/xmc7200d_x8384_cm7_0.icf"  attr="config" version="1.0.0" condition="CM7_0 IAR LINKER"/>
      <file category="linkerScript"  name="Libraries/mtb-template-cat1/files/templates/cat1c/COMPONENT_MTB/COMPONENT_CM7/TOOLCHAIN_IAR/xmc7200d_x8384_cm7_1.icf"  attr="config" version="1.0.0" condition="CM7_1 IAR LINKER"/>
    </files>
  </component>

  <component Cclass="Device" Cgroup="Peripheral Driver Library" Csub="PDL" condition="CMSIS" Cversion="3.10.0">
      <description>MTB CAT1 Peripheral driver library</description>
      <files>
        <file category="doc"     name="Libraries/mtb-pdl-cat1/docs/pdl_api_reference_manual/html/index.html"/>
        <file category="include" name="Libraries/mtb-pdl-cat1/drivers/include/"/>
        <file category="include" name="Libraries/mtb-pdl-cat1/drivers/third_party/ethernet/include/"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_mem_v1.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_hw_v1.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_hw.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_hmac_v2.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_hmac_v1.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_hkdf_v2.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_ecc_nist_p.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_ecc_key_gen.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_ecc_ecdsa.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_ecc_domain_params.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_des_v2.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_des_v1.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_crc_v2.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_crc_v1.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_cmac_v2.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_cmac_v1.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_aes_v2.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_aes_v1.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_canfd.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_ble_clk.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_adcmic.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_pdm_pcm_v2.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_pdm_pcm.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_mcwdt.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_mcwdt_b.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_lvd_ht.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_lvd.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_lpcomp.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_lin.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_keyscan.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_ipc_sema.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_ipc_pipe.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_ipc_drv.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_ipc_bt.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_i2s.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_gpio.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_flash_v2.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_flash_srom.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_flash.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_evtgen.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_ethif.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_ephy.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_efuse_v3.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_efuse.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_dmac.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_dma.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_ctdac.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_ctb.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_csd.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_server.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_cryptolite_vu.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_cryptolite_utils.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_cryptolite_trng.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_cryptolite_sha256.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_cryptolite_rsa.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_cryptolite_nist_p.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_cryptolite_hmac.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_cryptolite_hkdf.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_cryptolite_ecdsa.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_cryptolite_ecc_key_gen.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_cryptolite_cmac.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_cryptolite_aes_ccm.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_cryptolite_aes.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_vu.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_trng.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_sha_v2.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_sha_v1.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_rsa.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_prng_v2.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_prng_v1.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_mem_v2.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_sysclk.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_sysanalog.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_smif_sfdp.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_smif_memslot.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_smif_hb_flash.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_smif.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_smartio.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_seglcd.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_sd_host.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_scb_uart.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_scb_spi.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_scb_i2c.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_scb_ezi2c.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_scb_common.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_sar.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_sar2.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_rtc.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_prot.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_profile.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_pra_cfg.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_pra.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/ppu_v1.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_wdt.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_wdt_b.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_usbfs_dev_drv_io_dma.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_usbfs_dev_drv_io.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_usbfs_dev_drv.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_trigmux.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_tdm.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_tcpwm_shiftreg.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_tcpwm_quaddec.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_tcpwm_pwm.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_tcpwm_counter.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_systick_v2.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_systick.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_syspm_v4.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_syspm_v3.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_syspm_v2.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_syspm_ppu.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_syspm_pdcm.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_syspm.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_syspm_btss.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_syslib.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_sysint_v2.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_sysint.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_sysfault.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/cy_sysclk_v2.c"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/TOOLCHAIN_GCC_ARM/cy_syslib_ext_gcc.S" condition="GCC"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/TOOLCHAIN_IAR/cy_syslib_ext_iar.s" condition="IAR"/>
        <file category="source"  name="Libraries/mtb-pdl-cat1/drivers/source/TOOLCHAIN_ARM/cy_syslib_ext_armcc.s" condition="ARMCC"/>
        <file category="source" name="Libraries/mtb-pdl-cat1/drivers/third_party/ethernet/src/edd_rx.c"/>
        <file category="source" name="Libraries/mtb-pdl-cat1/drivers/third_party/ethernet/src/edd_tx.c"/>
        <file category="source" name="Libraries/mtb-pdl-cat1/drivers/third_party/ethernet/src/edd.c"/>
        <file category="source" name="Libraries/mtb-pdl-cat1/drivers/source/cy_cordic.c"/>
        <file category="source" name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_ecc_ec25519.c"/>
        <file category="source" name="Libraries/mtb-pdl-cat1/drivers/source/cy_crypto_core_ecc_eddsa.c"/>
        <file category="source" name="Libraries/mtb-pdl-cat1/drivers/source/cy_hppass.c"/>
        <file category="source" name="Libraries/mtb-pdl-cat1/drivers/source/cy_hppass_ac.c"/>
        <file category="source" name="Libraries/mtb-pdl-cat1/drivers/source/cy_hppass_csg.c"/>
        <file category="source" name="Libraries/mtb-pdl-cat1/drivers/source/cy_hppass_sar.c"/>
        <file category="source" name="Libraries/mtb-pdl-cat1/drivers/source/cy_mpc.c"/>
        <file category="source" name="Libraries/mtb-pdl-cat1/drivers/source/cy_ms_ctl.c"/>
        <file category="source" name="Libraries/mtb-pdl-cat1/drivers/source/cy_ppc.c"/>
        <file category="source" name="Libraries/mtb-pdl-cat1/drivers/source/cy_tcpwm_motif.c"/>
      </files>
  </component>
</components>
</package>