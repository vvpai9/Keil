<?xml version="1.0" encoding="utf-8"?>

<package schemaVersion="1.4" xmlns:xs="http://www.w3.org/2001/XMLSchema-instance" xs:noNamespaceSchemaLocation="PACK.xsd">
    <vendor>TexasInstruments</vendor>
    <name>MSPM0G511X_G518X_DFP</name>
    <description>Device Family Pack for Texas Instruments MSPM0G511X_G518X Series</description>
    <url>https://software-dl.ti.com/msp430/esd/MSPM0-CMSIS/MSPM0G511X_G518X/latest/exports/</url>
    <supportContact>https://e2e.ti.com/support/microcontrollers/</supportContact>
    <license>01_Pack/license.txt</license>

    <releases>
        <release version="1.0.0" date="2024-08-26">
        Initial release of MSPM0G511X/G518X series device familiy pack.
        New device support:
            * MSPM0G511X
            * MSPM0G518X
        </release>
    </releases>

    <keywords>
        <!-- keywords for indexing -->
        <keyword>Texas Instruments</keyword>
        <keyword>MSPM0</keyword>
        <keyword>MSPM0G</keyword>
        <keyword>MSPM0GXX</keyword>
        <keyword>MSPM0G511X</keyword>
        <keyword>MSPM0G518X</keyword>
        <keyword>Device Support</keyword>
        <keyword>Device Family Package Texas Instruments</keyword>
      </keywords>
  
    <!-- devices section (mandatory for Device Family Packs) -->
    <devices>
        <family Dfamily="MSPM0G511X_G518X Series" Dvendor="Texas Instruments:16">
            <processor Dcore="Cortex-M0+" DcoreVersion="r0p1" Dfpu="NO_FPU" Dclock="80000000" Dmpu="MPU" Dendian="Little-endian"/>
            <debugconfig default="swd" clock="5000000" swj="1"/>
            <book name="https://developer.arm.com/documentation/dui0662/latest/" title="Cortex-M0+ Generic User Guide"/>
            <description>
The MSPM0G511x and MSPM0G518x microcontrollers (MCUs) are part of MSP's
highly-integrated, low-power 32-bit MCU family based on the enhanced Arm®
Cortex®-M0+ 32-bit core platform operating at up to 80-MHz frequency.
These MCUs offer a blend of cost optimization and design flexibility for
applications requiring 32KB to 128KB of flash memory in small packages
(down to 4 mm x 4 mm) or high pin count packages (up to 64 pins).
These devices include cybersecurity enablers, high performance
integrated analog, and provide excellent low power performance across the
operating temperature range.

Up to 128 KB of embedded flash program memory with built-in error correction
code (ECC) and up to 32 KB SRAM with ECC and parity protection is provided.
The flash memory is organized into two main banks to support field firmware
updates, with address swap support provided between the two main banks.

A USB 2.0 full-speed interface (with integrated PHY) is provided to support
compliant device and host mode functionality. Four Unified Communication
Modules (UNICOMM) are provided to combine infrastructure elements and an
efficient overlaid serial peripherals, supporting up to three UART, two I2C,
or two SPI. Digital audio interface is provided for a variety of audio
applications and support multiple protocols such as I2S and TDM.

Flexible cybersecurity enablers can be used to support secure boot, secure
in-field firmware updates, IP protection (execute-only memory), key storage,
and more. Hardware acceleration is provided for a variety of AES symmetric
cipher modes. The cybersecurity architecture is pending Arm PSA Level 1
certification.

A set of high performance analog modules is provided, such as one sampling
12-bit 1.6-Msps ADCs supporting up to 26 external channels, on-chip voltage
reference (1.4V or 2.5V), and one high speed comparators with built-in 8-bit
reference DAC.
            </description>
            <debug>
                <!-- Patched ROM Table for a Cortex-M0+ -->
                <datapatch  type="AP" __dp="0" __ap="0" address="0xF8" value="0xF0000003" info="AP BASE Register, ROM Table at 0xF0000002"/>
            </debug>
            <!-- debug sequences -->  
            <sequences>
                <sequence name="DebugPortSetup">
                    <block>
                        __var isSWJ      = ((__protocol &amp; 0x00010000) != 0);
                        __var hasDormant = __protocol &amp; 0x00020000;
                        __var protType   = __protocol &amp; 0x0000FFFF;
                    </block>
                    <!-- JTAG Protocol -->
                    <control if="protType == 1">
                        <control if="isSWJ">
                            <control if="hasDormant">
                                <block atomic="1">
                                    // Ensure current debug interface is in reset state
                                    DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF);
                                    // Select Dormant State (from SWD)
                                    DAP_SWJ_Sequence(16, 0xE3BC);                            
                                    // At least 8 cycles SWDIO/TMS HIGH
                                    DAP_SWJ_Sequence(8, 0xFF);                            
                                    // Alert Sequence Bits  0.. 63
                                    DAP_SWJ_Sequence(64, 0x86852D956209F392);                            
                                    // Alert Sequence Bits 64..127
                                    DAP_SWJ_Sequence(64, 0x19BC0EA2E3DDAFE9);
                                    // 4 cycles SWDIO/TMS LOW + 8-Bit JTAG Activation Code (0x0A)            
                                    DAP_SWJ_Sequence(12, 0x0A0);
                                    // Ensure JTAG interface is reset
                                    DAP_SWJ_Sequence(6, 0x3F);
                                </block>
                            </control>
                            <control if="!hasDormant">                    
                                <block atomic="1">
                                // Ensure current debug interface is in reset state
                                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF);                            
                                // Execute SWJ-DP Switch Sequence SWD to JTAG (0xE73C)
                                // Change if SWJ-DP uses deprecated switch code (0xAEAE)
                                DAP_SWJ_Sequence(16, 0xE73C);                            
                                // Ensure JTAG interface is reset
                                DAP_SWJ_Sequence(6, 0x3F);
                                </block>                    
                            </control>                    
                        </control>
                            <block atomic="1">
                                // JTAG "Soft" Reset
                                DAP_JTAG_Sequence(6, 1, 0x3F);
                                DAP_JTAG_Sequence(1, 0, 0x01);
                            </block>
                    </control>

                    <!-- SWD Protocol -->
                    <control if="protType == 2">
                        <control if="isSWJ">
                            <control if="hasDormant">
                                <block atomic="1">
                                    // Ensure current debug interface is in reset state
                                    DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF);                            
                                    // Select Dormant State (from JTAG)
                                    DAP_SWJ_Sequence(31, 0x33BBBBBA);                            
                                    // At least 8 cycles SWDIO/TMS HIGH
                                    DAP_SWJ_Sequence(8, 0xFF);                            
                                    // Alert Sequence Bits  0.. 63
                                    DAP_SWJ_Sequence(64, 0x86852D956209F392);                            
                                    // Alert Sequence Bits 64..127
                                    DAP_SWJ_Sequence(64, 0x19BC0EA2E3DDAFE9);
                                    // 4 cycles SWDIO/TMS LOW + 8-Bit SWD Activation Code (0x1A)            
                                    DAP_SWJ_Sequence(12, 0x1A0);
                                    // Enter SWD Line Reset State
                                    DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF);  // &gt; 50 cycles SWDIO/TMS High
                                    DAP_SWJ_Sequence(3,  0x00);                // At least 2 idle cycles (SWDIO/TMS Low)
                                </block>
                            </control>
                            <control if="!hasDormant">
                                <block>
                                    // Ensure current debug interface is in reset state
                                    DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); //lets put the JTAG line in a reset state
                                    DAP_SWJ_Sequence(16,0xE73C); //SWD to JTAG, this is to ensure the state machine is initialized
                                    DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF); //Put it back in reset
                                    DAP_SWJ_Sequence(16, 0xE79E); //JTAG to SWD switch
                                    DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF);  //Ensure the switch is successful 
                                    DAP_SWJ_Sequence(7,  0x00); //Give the line some time to initialize
                                </block>
                            </control>
                        </control>
                        <control if="!isSWJ">
                            <control if="hasDormant">
                                <block atomic="1">
                                // Ensure current debug interface is in reset state
                                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF);
                                
                                // At least 8 cycles SWDIO/TMS HIGH
                                DAP_SWJ_Sequence(8, 0xFF);
                                
                                // Alert Sequence Bits  0.. 63
                                DAP_SWJ_Sequence(64, 0x86852D956209F392);
                                
                                // Alert Sequence Bits 64..127
                                DAP_SWJ_Sequence(64, 0x19BC0EA2E3DDAFE9);
                        
                                // 4 cycles SWDIO/TMS LOW + 8-Bit SWD Activation Code (0x1A)            
                                DAP_SWJ_Sequence(12, 0x1A0);
                                
                                // Enter SWD Line Reset State
                                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF);  // &gt; 50 cycles SWDIO/TMS High
                                DAP_SWJ_Sequence(3,  0x00);                // At least 2 idle cycles (SWDIO/TMS Low)
                                </block>
                            </control>
                            <control if="!hasDormant">
                                <block atomic="1">
                                // Enter SWD Line Reset State
                                DAP_SWJ_Sequence(51, 0x0007FFFFFFFFFFFF);  // &gt; 50 cycles SWDIO/TMS High
                                DAP_SWJ_Sequence(3,  0x00);                // At least 2 idle cycles (SWDIO/TMS Low)
                                </block>
                            </control>
                        </control>
                        <block>
                            // Read DPIDR to enable SWD interface (SW-DPv1 and SW-DPv2)
                            ReadDP(0x0);
                        </block>
                    </control>
                </sequence>
                <sequence name="DebugPortStart">

                    <block>
                        __var SW_DP_ABORT       = 0x0;
                        __var DP_CTRL_STAT      = 0x4;
                        __var DP_SELECT         = 0x8;
                        __var powered_down      = 0;

                        //Beyond here do not modify
                        // Switch to DP Register Bank 0
                        WriteDP(DP_SELECT, 0x00000000);

                        // Read DP CTRL/STAT Register and check if CSYSPWRUPACK and CDBGPWRUPACK bits are set
                        powered_down = ((ReadDP(DP_CTRL_STAT) &amp; 0xA0000000) != 0xA0000000);
                    </block>
                    <control if="powered_down">
                        <block>
                            // Request Debug/System Power-Up
                            Message(0, "Debug/System power-up request sent");
                            WriteDP(DP_CTRL_STAT, 0x50000000);
                        </block>
                        
                        <!-- Wait for Power-Up Request to be acknowledged -->
                        <control while="(ReadDP(DP_CTRL_STAT) &amp; 0xA0000000) != 0xA0000000" timeout="1000000"/>
                        
                        <!-- JTAG Specific Part of sequence -->
                        <control if="(__protocol &amp; 0xFFFF) == 1">
                        
                            <block>
                                // Init AP Transfer Mode, Transaction Counter, and Lane Mask (Normal Transfer Mode, Include all Byte Lanes)
                                // Additionally clear STICKYORUN, STICKYCMP, and STICKYERR bits by writing '1'
                                WriteDP(DP_CTRL_STAT, 0x50000F32);
                            </block>
                        
                        </control>
                        
                        <!-- SWD Specific Part of sequence -->
                        <control if="(__protocol &amp; 0xFFFF) == 2">
                            <block>
                                Message(0, "executing SWD power up");
                                // Init AP Transfer Mode, Transaction Counter, and Lane Mask (Normal Transfer Mode, Include all Byte Lanes)
                                WriteDP(DP_CTRL_STAT, 0x50000F00);
                                
                                // Clear WDATAERR, STICKYORUN, STICKYCMP, and STICKYERR bits of CTRL/STAT Register by write to ABORT register
                                WriteDP(SW_DP_ABORT, 0x0000001E);
                            </block>
                        </control>
                    </control>
                    <block>
                        __var DEBUG_PORT_VAL    = 0;
                        __var ACCESS_POINT_VAL  = 0;

                        __ap = 1; 
                        WriteAP(0x0C, 0x04); //lets use the mini pwr-ap as backup
                        
                        __ap = 4;
                        ACCESS_POINT_VAL = ReadAP(0x00);//Reading current state of access point
                        Message(0, "Current state of access point is: %x",ACCESS_POINT_VAL);
                        WriteAP(0x00, 0x100008);
                        DAP_Delay(5000);
                    </block>
                    <block>
                        __var nReset = 0x80;
                        __var canReadPins = 0;
                        __var BOOTDIAG_READ = 0;
                        __var AHB_STATUS = 0;
                        __ap = 1;
                        BOOTDIAG_READ = ReadAP(0x10);
                        __ap = 0;
                        AHB_STATUS = ReadAP(0xFC);
                        __ap = 4;
                    </block>
                    <control if = "(BOOTDIAG_READ == 0x07)">
                        <!-- If the AHB IDR can be read then we do nothing, otherwise there is an issue-->
                        <control if = "!AHB_STATUS">
                            <block>
                                Query(0, "Cannot view the AHB-AP, debug access has been disabled or nested exception occured. Please reset the device.",1);
                            </block>
                        </control>
                    </control>
                    <control if = "(BOOTDIAG_READ == 0x36)">
                        <!-- NONMAIN has been corrupted due to a possiblity of several reason but device cannot be accessed-->
                        <block>
                            Query(0, "NONMAIN has been corrupted, this can be caused by erasing without programming, invalid BCR/BSL CRC value, or incorrectly modifying NONMAIN",1);
                        </block>
                    </control>
                    <control if = "(BOOTDIAG_READ == 0x0004110A)">
                        <block>
                            // De-assert nRESET line to activate the hardware reset
                            canReadPins = (DAP_SWJ_Pins(0x00, nReset, 0) != 0xFFFFFFFF);
                        </block>
                        <!-- Keep reset active for 50 ms -->
                        <control while="1" timeout="200"/>
                        <control if="canReadPins">
                            <!-- Assert nRESET line and wait max. 1s for recovery -->
                            <control while="(DAP_SWJ_Pins(nReset, nReset, 0) &amp; nReset) == 0" timeout="1000000"/>
                        </control>
                        <control if="!canReadPins">
                            <block>
                            // Assert nRESET line
                            DAP_SWJ_Pins(nReset, nReset, 0);
                            </block>
                            <!-- Wait 100ms for recovery if nRESET not readable -->
                            <control while="1" timeout="100000"/>
                        </control>
                    </control>
                    <control if = "(ACCESS_POINT_VAL &amp; 0x00E00000) == 0">
                        <block>
                            WriteAP(0x00, 0x190008);
                            WriteAP(0xF0, 0x01);
                        </block> 
                    </control>
                    <control if = "(ACCESS_POINT_VAL &amp; 0x00E00000) != 0">
                        <block>
                            WriteAP(0xF0, 0x01);
                            WriteAP(0x00, 0xF90008);
                            WriteAP(0xF0, 0x01);
                        </block>
                    </control>
                    <block>
                        ACCESS_POINT_VAL = ReadAP(0x00);//Reading current state of access point
                        Message(0, "Current state of access point is: %x",ACCESS_POINT_VAL);
                        __ap = 0; //lets make sure we reset the access point selection
                    </block>
                </sequence>
                <sequence name="DebugDeviceUnlock">
                    <block>
                        __ap = 1;
                        __var deviceID = 0;
                        __var version = 0;
                        __var partNum = 0;
                        __var manuf = 0;
                        __var isMSPM0G511X_G518X = 0;
                        __var isProduction = 0;
                        __var continueId = 0;
                        deviceID =   ReadAP(0x00);
                        version = deviceID >> 28;
                        partNum = (deviceID &amp; 0x0FFFF000) >> 12;
                        manuf = (deviceID &amp; 0x00000FFE) >> 1;
                        isMSPM0G511X_G518X = (partNum == 0xBBBC) &amp;&amp; (manuf == 0x17);
                        isProduction = (version &gt; 0);
                    </block>
                    <!-- Check if device ID is correct -->
                    <control if="!isMSPM0G511X_G518X">
                        <block>
                            continueId = Query(1, "Incorrect ID. This support package is for MSPM0G511X_G518X devices. Continue?", 4);
                        </block>
                    </control>
                    <control if="continueId == 4">
                        <block>
                            Message(2, "Invalid ID");
                        </block>
                    </control>
                </sequence>
                <sequence name="ResetSystem">
                    <block>
                        // System Control Space (SCS) offset as defined in Armv6-M/Armv7-M.
                        __ap = 4;
                        WriteAP(0xF0, 0x01);
                        DAP_Delay(20000); 
                    </block>
                    <block>
                        // System Control Space (SCS) offset as defined in Armv6-M/Armv7-M.
                        __var SCS_Addr   = 0xE000E000;
                        __var AIRCR_Addr = SCS_Addr + 0xD0C;
                        __var DHCSR_Addr = SCS_Addr + 0xDF0;
                
                        // Execute SYSRESETREQ via AIRCR
                        Write32(AIRCR_Addr, 0x05FA0004);
                    </block>
                    <!-- Reset Recovery: Wait for DHCSR.S_RESET_ST bit to clear on read -->
                    <control while="(Read32(DHCSR_Addr) &amp; 0x02000000)" timeout="500000"/>
                </sequence>
            </sequences>
            <!-- features common for the whole family -->
            <feature type="NVIC" n="32" name="Nested Vectored Interrupt Controller (NVIC)"/>
            <feature type="DMA" n="12" name="Direct Memory Access (DMA)"/>
            <feature type="MemoryOther" name="Up to 128KB Flash memory with built-in error correction code (ECC)"/>
            <feature type="MemoryOther" name="Up to 32KB SRAM with hardware parity"/>
            <feature type="XTAL" n="4000000" m="48000000" name="High Frequency crystal (HFXT)"/>
            <feature type="PLL" n="1" name="Internal PLL"/>
            <feature type="RTC" n="32768" name="Internal RTC with alarm and calendar modes"/>
            <feature type="ClockOther" name="Internal 4-32MHz oscillator with +-1% accuracy (SYSOSC)"/>
            <feature type="ClockOther" name="Internal 32kHz oscillator (LFOSC)"/>
            <feature type="ClockOther" name="Low Frequency 32kHz crystal (LFXT)"/>
            <feature type="PowerMode" n="12" name="RUN0, RUN1, RUN2, SLEEP0, SLEEP1, SLEEP2, STOP0, STOP1, STOP2, STANDBY0, STANDBY1, SHUTDOWN"/>
            <feature type="VCC" n="1.62" m="3.6"/>
            <feature type="Temp" n="-40" m="125" name="Extended Operating Temperature Range"/>
            <feature type="AnalogOther" n="1" name="High-speed comparator (COMP) with 8-bit reference DACs"/>
            <feature type="AnalogOther" n="1" name="Configurable 1.4V or 2.5V internal shared voltage reference (VREF)"/>
            <feature type="Timer" n="14" m="16" name="Four 16-bit advanced timers with deadband supporting up to 14 PWM channels"/>
            <feature type="TimerOther" n="2" name="16-bit general purpose timer"/>
            <feature type="TimerOther" n="1" name="16-bit general purpose timer supporting low power operation in STANDBY mode"/>
            <feature type="TimerOther" n="1" name="16-bit advanced timers with deadband support up to 12 PWM channels"/>
            <feature type="TimerOther" n="1" name="One basic software timer including 4 independent configuration 16-bit counters"/>
            <feature type="WDT" n="3" name="Two Window-watchdog timer (WWDT), one independent watchdog timer (IWDT)"/>
            <feature type="MPSerial" n="4" name="Four configurable serial interfaces supporting up to three UART modules, up to two I2C modules, and up to two SPI modules."/>
            <feature type="I2S" n="1" name="One digital audio interface supporting several standardized serial interfaces to audio device"/>
            <feature type="Crypto" n="128.256" name="HW accelerated AES Encryption/Decryption Engine"/>
            <feature type="ADC" n="26" m="12" name="One simultaneous 4MSPS analog-to-digital converters (ADC)"/>
            <feature type="IOs" n="59" name="General purpose I/Os, including two 5-V tolerant, three high-drive with 20mA drive strength, and two high-speed "/>
            <feature type="USBD" n="1" name="One USB2.0 interface supporting full-speed (12-Mbps) compliant device and host mode functionality"/>
<!-- ************************  Subfamily MSPM0G511X  **************************** -->
            <subFamily DsubFamily="MSPM0G511X">
                <!-- *************************  Device MSPM0G5117  ***************************** -->
                <device Dname="MSPM0G5117">
                    <memory     name="IROM1" access="rx"  start="0x00000000" size="0x00020000" startup="1" default="1"/>
                    <memory     name="IROM2" access="rx"  start="0x00400000" size="0x00020000" default="0" alias="IROM1"/>
                    <memory     name="IRAM1" access="rwx" start="0x20000000" size="0x00008000" default="0"/>
                    <memory     name="IRAM_Parity" access="rwx" start="0x20100000" size="0x00008000" default="0" alias="IRAM1"/>
                    <memory     name="IRAM_No_Parity" access="rwx" start="0x20200000" size="0x00008000" default="1" alias="IRAM1"/>
                    <memory     name="IRAM_Parity_Code" access="rwx" start="0x20300000" size="0x00008000" default="0" alias="IRAM1"/>
                    <memory     name="NonMain_ECC" access="r"  start="0x41C00000" size="0x00000800" default="1"/>
                    <memory     name="Factory_ECC" access="r"  start="0x41C40000" size="0x00000200" default="1"/>
                    <memory     name="Data" access="r"  start="0x41D00000" size="0x00004000" default="1"/>
                    <compile    define="__MSPM0G5117__"/>
                    <debug      svd="03_SVD/MSPM0G511X.svd"/>
                    <algorithm  name="02_Flash_Programming/FlashARM/MSPM0G511X_G518X_MAIN_128KB.FLM" start="0x00000000" size="0x00020000" RAMstart="0x20200000" RAMsize="0x00008000" default="1"/>
                    <algorithm  name="02_Flash_Programming/FlashARM/MSPM0G511X_G518X_NONMAIN.FLM" start="0x41C00000" size="0x00000800" RAMstart="0x20200000" RAMsize="0x00008000" default="0"/>
                    <algorithm  name="02_Flash_Programming/FlashARM/MSPM0G511X_G518X_DATA_8KB.FLM" start="0x41D00000" size="0x00004000" RAMstart="0x20200000" RAMsize="0x00008000" default="0"/>
                </device>
                <!-- *************************  Device MSPM0G5116  ***************************** -->
                <device Dname="MSPM0G5116">
                    <memory     name="IROM1" access="rx"  start="0x00000000" size="0x00010000" startup="1" default="1"/>
                    <memory     name="IROM2" access="rx"  start="0x00400000" size="0x00010000" default="0" alias="IROM1"/>
                    <memory     name="IRAM1" access="rwx" start="0x20000000" size="0x00008000" default="0"/>
                    <memory     name="IRAM_Parity" access="rwx" start="0x20100000" size="0x00008000" default="0" alias="IRAM1"/>
                    <memory     name="IRAM_No_Parity" access="rwx" start="0x20200000" size="0x00008000" default="1" alias="IRAM1"/>
                    <memory     name="IRAM_Parity_Code" access="rwx" start="0x20300000" size="0x00008000" default="0" alias="IRAM1"/>
                    <memory     name="NonMain_ECC" access="r"  start="0x41C00000" size="0x00000800" default="1"/>
                    <memory     name="Factory_ECC" access="r"  start="0x41C40000" size="0x00000200" default="1"/>
                    <memory     name="Data" access="r"  start="0x41D00000" size="0x00004000" default="1"/>
                    <compile    define="__MSPM0G5116__"/>
                    <debug      svd="03_SVD/MSPM0G511X.svd"/>
                    <algorithm  name="02_Flash_Programming/FlashARM/MSPM0G511X_G518X_MAIN_64KB.FLM" start="0x00000000" size="0x00010000" RAMstart="0x20200000" RAMsize="0x00008000" default="1"/>
                    <algorithm  name="02_Flash_Programming/FlashARM/MSPM0G511X_G518X_NONMAIN.FLM" start="0x41C00000" size="0x00000800" RAMstart="0x20200000" RAMsize="0x00008000" default="0"/>
                    <algorithm  name="02_Flash_Programming/FlashARM/MSPM0G511X_G518X_DATA_8KB.FLM" start="0x41D00000" size="0x00004000" RAMstart="0x20200000" RAMsize="0x00008000" default="0"/>
                </device>
                <!-- *************************  Device MSPM0G5115  ***************************** -->
                <device Dname="MSPM0G5115">
                    <memory     name="IROM1" access="rx"  start="0x00000000" size="0x00008000" startup="1" default="1"/>
                    <memory     name="IROM2" access="rx"  start="0x00400000" size="0x00008000" default="0" alias="IROM1"/>
                    <memory     name="IRAM1" access="rwx" start="0x20000000" size="0x00004000" default="0"/>
                    <memory     name="IRAM_Parity" access="rwx" start="0x20100000" size="0x00004000" default="0" alias="IRAM1"/>
                    <memory     name="IRAM_No_Parity" access="rwx" start="0x20200000" size="0x00004000" default="1" alias="IRAM1"/>
                    <memory     name="IRAM_Parity_Code" access="rwx" start="0x20300000" size="0x00004000" default="0" alias="IRAM1"/>
                    <memory     name="NonMain_ECC" access="r"  start="0x41C00000" size="0x00000800" default="1"/>
                    <memory     name="Factory_ECC" access="r"  start="0x41C40000" size="0x00000200" default="1"/>
                    <memory     name="Data" access="r"  start="0x41D00000" size="0x00004000" default="1"/>
                    <compile    define="__MSPM0G5115__"/>
                    <debug      svd="03_SVD/MSPM0G511X.svd"/>
                    <algorithm  name="02_Flash_Programming/FlashARM/MSPM0G511X_G518X_MAIN_32KB.FLM" start="0x00000000" size="0x00008000" RAMstart="0x20200000" RAMsize="0x00004000" default="1"/>
                    <algorithm  name="02_Flash_Programming/FlashARM/MSPM0G511X_G518X_NONMAIN.FLM" start="0x41C00000" size="0x00000800" RAMstart="0x20200000" RAMsize="0x00004000" default="0"/>
                    <algorithm  name="02_Flash_Programming/FlashARM/MSPM0G511X_G518X_DATA_8KB.FLM" start="0x41D00000" size="0x00004000" RAMstart="0x20200000" RAMsize="0x00004000" default="0"/>
                </device>
            </subFamily>
<!-- ************************  Subfamily MSPM0G518X  **************************** -->
            <subFamily DsubFamily="MSPM0G518X">
                <feature type="Other" name="Neural-network Processing Unit (NPU) supporting machine learning inference using pre-trained models"/>
                <!-- *************************  Device MSPM0G5187  ***************************** -->
                <device Dname="MSPM0G5187">
                    <memory     name="IROM1" access="rx"  start="0x00000000" size="0x00020000" startup="1" default="1"/>
                    <memory     name="IROM2" access="rx"  start="0x00400000" size="0x00020000" default="0" alias="IROM1"/>
                    <memory     name="IRAM1" access="rwx" start="0x20000000" size="0x00008000" default="0"/>
                    <memory     name="IRAM_Parity" access="rwx" start="0x20100000" size="0x00008000" default="0" alias="IRAM1"/>
                    <memory     name="IRAM_No_Parity" access="rwx" start="0x20200000" size="0x00008000" default="1" alias="IRAM1"/>
                    <memory     name="IRAM_Parity_Code" access="rwx" start="0x20300000" size="0x00008000" default="0" alias="IRAM1"/>
                    <memory     name="NonMain_ECC" access="r"  start="0x41C00000" size="0x00000800" default="1"/>
                    <memory     name="Factory_ECC" access="r"  start="0x41C40000" size="0x00000200" default="1"/>
                    <memory     name="Data" access="r"  start="0x41D00000" size="0x00004000" default="1"/>
                    <compile    define="__MSPM0G5187__"/>
                    <debug      svd="03_SVD/MSPM0G518X.svd"/>
                    <algorithm  name="02_Flash_Programming/FlashARM/MSPM0G511X_G518X_MAIN_128KB.FLM" start="0x00000000" size="0x00020000" RAMstart="0x20200000" RAMsize="0x00008000" default="1"/>
                    <algorithm  name="02_Flash_Programming/FlashARM/MSPM0G511X_G518X_NONMAIN.FLM" start="0x41C00000" size="0x00000800" RAMstart="0x20200000" RAMsize="0x00008000" default="0"/>
                    <algorithm  name="02_Flash_Programming/FlashARM/MSPM0G511X_G518X_DATA_8KB.FLM" start="0x41D00000" size="0x00004000" RAMstart="0x20200000" RAMsize="0x00008000" default="0"/>
                </device>
            </subFamily>
        </family>
    </devices>

    <boards>
        <board vendor="TexasInstruments" name="LP-MSPM0G5187" salesContact="http://www.ti.com/general/docs/contact.tsp">
            <description>MSPM0G5187 LaunchPad</description>
            <mountedDevice    deviceIndex="0" Dvendor="Texas Instruments:16" Dname="MSPM0G5187"/>
            <compatibleDevice deviceIndex="0" Dvendor="Texas Instruments:16" Dfamily="MSPM0G518X Series" DsubFamily="MSPM0G518X"/> 
            <debugInterface adapter="XDS110-ET" connector="XDS110-ET Onboard Emulator"/>  
            <debugInterface adapter="SWD" connector="10-pin Cortex Debug Connector (0.05 inch connector)"/>
            <feature type="USB" n="1" name="USB Device,  Micro-B receptacle"/>
            <feature type="Button" n="3" name="reset and two user push-buttons"/>
            <feature type="LED" n="4" name="LEDs for user interaction, including 1 RGB LED"/> 
            <feature type="ConnOther" n="4" name="2x40 pin BoosterPack Connector and support for 20 pin BoosterPacks"/>
            <feature type="TempSens" n="1" name="Temperature sensor circuit"/>
            <feature type="LightSens" n="1" name="Light sensor circuit"/>
            <feature type="SensOther" n="1" name="External OPA2365 for 4MSPS ADC evaluation"/>
            <feature type="XTAL" n="48000000"/>
            <feature type="Other" name="EnergyTrace technology available for ultra-low-power debugging"/>
            <feature type="Other" name="32kHz crystal"/>
        </board>
    </boards>

</package>
