<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>FAT File System</title>
<title>File System Component: FAT File System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="drv.css" rel="stylesheet" type="text/css" />
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="stylsheetf" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 46px;">
  <td id="projectlogo"><img alt="Logo" src="keilarm.png"/></td>
  <td style="padding-left: 0.5em;">
   <div id="projectname">File System Component
   &#160;<span id="projectnumber">Version 5.0</span>
   </div>
   <div id="projectbrief">MDK-Professional Middleware for Devices with Flash File System</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<div id="DRVnav" class="tabs1">
    <ul class="tablist">
      <li id="GEN">   <a href="../../General/html/index.html"><span>General</span></a></li>
      <li id="FS"     class="current">    <a href="../../FileSystem/html/index.html"><span>File System</span></a></li>
      <li id="GRA">   <a href="../../Graphic/html/index.html"><span>Graphic</span></a></li>
      <li id="NET">   <a href="../../Network/html/index.html"><span>Network</span></a></li>
      <li id="USB">   <a href="../../USB/html/index.html"><span>USB</span></a></li>
    </ul>
</div>
<!-- Generated by Doxygen 1.8.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Usage&#160;and&#160;Description</span></a></li>
      <li><a href="modules.html"><span>Reference</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('fat_fs.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Groups</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">FAT File System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The FAT File System was initially used on PC operating systems such as MS-DOS and early versions of Microsoft Windows. Still, it is widely used on <b>USB memory sticks</b> or <b>SD/SDHC/MMC cards</b> for file storage. It is simple, robust and offers good performance especially in embedded applications.</p>
<p>FAT is an acronym for <b>File Allocation Table</b>. This table provides the index of the files in the system and is statically allocated at the time of formatting the drive. It contains an entry for each cluster (a data storage area). The FAT's entries contain either the number of the next cluster in the file, or a marker indicating EOF (end of file), unused disk space, or other areas of the drive that are specially reserved. The drive's root directory contains the number of the first cluster of each file in the directory; the operating system traverses the FAT table, looking up the cluster number of each successive part of the file, until the end of the file is reached. Likewise, sub-directories are implemented as special files containing the directory entries of their respective files.</p>
<p>Since the first implementation, the maximum number of clusters of a drive has increased dramatically, and so the number of bits used to identify each cluster has grown. The versions of the FAT format are named after the number of table element bits: <b>FAT12</b>, <b>FAT16</b>, and <b>FAT32</b>. Each of these variants is is supported by the File System Component.</p>
<h1><a class="anchor" id="fat_layout"></a>
Layout</h1>
<p>The actual FAT file system is made up of four different sections: </p>
<table class="doxtable">
<tr>
<th>Section </th><th align="left">Description </th></tr>
<tr>
<td>Boot sector </td><td align="left">Contains machine startup code </td></tr>
<tr>
<td>File Allocation Table</td><td align="left">Contains the data region map; multiple entries might exist for redundancy purposes </td></tr>
<tr>
<td>Root Directory </td><td align="left">Stores information about the files and directories located in the root directory (FAT12/FAT16 only) </td></tr>
<tr>
<td>File Data Region </td><td align="left">Actual stored file data </td></tr>
</table>
<h1><a class="anchor" id="journaling_fat"></a>
Journaling</h1>
<p>The FAT File System supports <a href="http://en.wikipedia.org/wiki/Journaling_file_system" class="el" target="_blank">Journaling</a> which makes file I/O functions robust against system crashes or power failures. When FAT Journaling is enabled FAT (File Allocation Table) and Directory entries are protected.</p>
<p><b>FAT Journaling</b> keeps track of the changes in the file system using a <b>journal</b> before committing them to the main file system. In the event of a system failure, file system does not become corrupted. Only content of files that are opened in writing mode may be lost. Other files are not affected.</p>
<p>Journaling can be enabled individually for each drive that is using the FAT File System. For information on how to enable Journaling refer to:</p>
<ul>
<li><a class="el" href="mc_usage.html">Using Memory Card Devices</a></li>
<li><a class="el" href="usb_usage.html">Using USB Memory Sticks</a></li>
<li><a class="el" href="nand_usage.html">Using NAND Flash Devices</a></li>
</ul>
<h2>System Initialization and Drive Formatting</h2>
<p>There requirements for creating a <b>journal</b> are:</p>
<ul>
<li>the drive must be formatted with two FAT tables (two consecutive tables in the FAT section of the drive)</li>
<li>the drive must have at least 64 sectors (= 32kB) of contiguous free space at the end of a partition (in the last 1% space).</li>
</ul>
<p>If journaling is enabled, mounting a drive triggers the File System to search for the journal.</p>
<p>When journal is found the journaling system is initialized and the journal content is checked for any incomplete data transactions that may be the result of a system crash. When incomplete data transactions are found the file system is restores the drive to the last known valid state.</p>
<p>When no journal is found, the journal is automatically created. The required space (32kB) for journal is reserved by marking the adequate amount of clusters in the last 1% of the drive partition. This reduces the reported amount of free space on the drive accordingly.</p>
<p>No special drive formatting is required. When a drive is formatted on a different computer (running Window or Linux) free space is typical available at the end of a partition. Creation of a journal may fail on removable media when above requirements are not meet. This may happen if the drive is fragmented or there is not enough space. In this case the drive should be defragmented or some files should be deleted.</p>
<p>When using the <a class="el" href="group__utility__routines.html#gaea20173a589e298b86791f1cc661731b">fformat</a> function of the File System component, the journal is automatically created on drives with enabled option "Use FAT Journal".</p>
<h2>System failure behaviour</h2>
<p>When File System component experiences a power loss or crashes before a file opened for writing is successfully closed the content of that file is lost. This results in lost data clusters which can be restored using a file system repair utility tool such as chkdsk on Windows or fsck on Linux.</p>
<h1><a class="anchor" id="nand_flash_TL"></a>
NAND Flash Translation Layer</h1>
<h2>NFTL Features</h2>
<ul>
<li>NAND types: MLC, SLC, TLC.</li>
<li>Up to 65536 blocks.</li>
<li>Up to 256 pages in block.</li>
<li><a class="el" href="fat_fs.html#wear_leveling">Wear Leveling</a>.</li>
<li><a class="el" href="fat_fs.html#bad_block_management">Bad Block Management</a>.</li>
<li><a class="el" href="fat_fs.html#slc_ecc">Error Correction Codes (ECC)</a> in software for SLC NAND Flash only.</li>
<li>Power fail safe.</li>
<li>OneNAND support.</li>
</ul>
<h2>NAND Flash Overview</h2>
<p>NAND Flash memory is used in USB drives, secure digital (SD) cards, memory sticks, CompactFlash cards and multimedia cards (MMC). It is a non-volatile memory with 60 percent smaller memory cells comparing to NOR memory cells thus offers high data density at a lower cost. It is organised into a series of blocks, which are the smallest erasable entities in a NAND Flash device. The smallest entity that can be programmed is a byte. Due to a limited number of times NAND Flash blocks can be reliably programmed and erased (nominally, each NAND block will survive 100000 program/erase cycles) it is critical to implement a <b>NAND Flash Translation Layer (NFTL)</b> to maximize the lifespan of the device. This layer comprises of wear levelling algorithms, bad block management and error control algorithms and thus maximizes the lifespan of a device by redirecting new writes to different physical blocks. It only applies to NAND Flash devices directly attached to the microcontroller.</p>
<dl class="section note"><dt>Note</dt><dd>External memory devices such as SD/SDHC/MMC card or USB sticks carry an integrated NAND Flash controller that is taking care of the NAND Flash in the device.</dd></dl>
<h2>NAND Flash Architecture</h2>
<p>A NAND Flash array is organized in blocks with multiple pages per block. Each page consist of user data area and spare data area. The spare data area is physically the same as user data area and is typically used for error correction information (ECC), wear levelling and other software system functions. The user data area is available to the user for data storage. The size of the user data area depends on the page size and is typically of one or multiple sector size.</p>
<h2><a class="anchor" id="wear_leveling"></a>
Wear Leveling</h2>
<p>Due to its architecture, data can be written to an address on a NAND flash memory only a finite number of times. NAND flash memory wears out if data is written too often to the same address, so wear levelling is used to help prolong the life of the NAND flash device. It ensures that data erasures and writes are distributed evenly across the NAND Flash storage medium, so that NAND memory blocks don't fail prematurely due to a high number of erase cycles.</p>
<p>Dynamic wear levelling addresses the issue of repeated writes to the same logical blocks by redirecting new writes to different physical blocks. Dynamic wear levelling works on data blocks that are being written to dynamically.</p>
<p>Static wear levelling addresses the issue of static data that is kept unchanged for a long time in content and location. Some static data can stay in the same data block until the NAND flash memory is broken. To evenly distribute write and erase cycles across NAND memory blocks, an algorithm is implemented to move the static data from one location to the other in the Flash.</p>
<p>The File System Component implements wear levelling for all kinds of NAND Flash devices (MLC, SLC, TLC).</p>
<h2><a class="anchor" id="bad_block_management"></a>
Bad Block Management</h2>
<p>It is normal for a NAND flash memory to contain bad or invalid blocks of memory. Invalid blocks are blocks that contain one or more invalid bits so that the reliability can no longer be guaranteed. Blocks can become invalid during erasing and programming at run-time or during the manufacturing process. Bad blocks generated during manufacturing process are marked bad by the manufacturer. Bad blocks detected at run-time are marked as bad by monitoring the status register in the NAND flash chip during an erase and program operation. A block that is marked as bad is skipped and no longer used.</p>
<p>The File System Component implements bad block management for all kinds of NAND Flash devices (MLC, SLC, TLC):</p>
<ul>
<li>Skip factory marked bad blocks</li>
<li>Mark block as bad as soon as an erase operation fails on the block</li>
<li>Replace/mode data from blocks marked as bad to good blocks</li>
</ul>
<h2><a class="anchor" id="slc_ecc"></a>
Error Correction Codes (ECC)</h2>
<p>Error detection and correction codes are used in flash memory to protect data from corruption. All types of error correction codes add redundant information to the data being stored to the flash memory. The redundant information is calculated before the data is written, added to the spare area of the page and then stored in flash memory. When the data is read, the redundant information is recalculated and compared to those stored in the flash.</p>
<p>Error correction codes (ECC) used in the NAND flash memory are block codes. This means that the redundant data bits are calculated for a fixed size block of used data. NTFL is implementing a <a href="http://en.wikipedia.org/wiki/Hamming_code" class="el" target="_blank">Hamming</a> ECC algorithm for a fixed size of one sector or 512 bytes for SLC NAND Flashes. The redundant information is calculated in a way that a balance of correction power and efficiency is achieved.</p>
<dl class="section warning"><dt>Warning</dt><dd>If you are using a <b>TLC</b> or <b>MLC</b> NAND Flash device, you need to <b>disable the Software ECC</b> in the <b>FS_Config_NAND_0.h</b> file, otherwise the File System will not function correctly. </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="fs_operation.html">Theory of Operation</a></li>
    <li class="footer">Generated on Thu Feb 20 2014 15:12:35 for File System Component by ARM Ltd. All rights reserved.
	<!--
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.2 
	-->
	</li>
  </ul>
</div>
</body>
</html>
