/******************************************************************************/
/* Int_RAM.ini: Internal RAM Initialization File                              */
/******************************************************************************/
// <<< Use Configuration Wizard in Context Menu >>>                           // 
/******************************************************************************/
/* This file is part of the uVision/ARM development tools.                    */
/* Copyright (c) 2005-2010 Keil Software. All rights reserved.                */
/* This software may only be used under the terms of a valid, current,        */
/* end user licence from KEIL for a compatible version of KEIL software       */
/* development tools. Nothing else gives you the right to use this software.  */
/******************************************************************************/


DEFINE CHAR Setup;
DEFINE INT  Entry;

DEFINE LONG PMC;
DEFINE LONG PIO_SD;
DEFINE LONG MATRIX;
DEFINE LONG SDRAMC;
DEFINE LONG SDRAM;

// Memory mapped peripherals address definitions
PMC    = 0xFFFFFC00;
MATRIX = 0xFFFFDE00;
SDRAM  = 0x20000000;


FUNC void Clock_Setup (void) {
  if (Setup & 0x01) {
    // Setup clock; XTAL            =  12.000 MHz
    //              PLLA            = 516.000 MHz
    //              Processor Clock = 258.000 MHz
    //              Master Clock    =  64.500 MHz
    _WDWORD(PMC+   0x20, 0x01370701);   // CKGR_MOR: Enable main oscillator
    _sleep_(1000);                       // Wait for stable Main Oscillator
    _WDWORD(PMC+   0x80, 0x00000001);   // PMC_PLLICPR: Charge Pump Current
    _WDWORD(PMC+   0x28, 0x202A4601);   // CKGR_PLLAR: Configure PLL A
    //_WDWORD(PMC+   0x30, 0x00000010);   // PMC_MCKR: PRES field
    _sleep_(2000);                       // Wait for Main Master Clock ready
    _WDWORD(PMC+   0x30, 0x00000212);   // PMC_MCKR: all fields
    _sleep_(1000);                       // Wait for Main Master Clock ready
  }
}

// This function originates mostly from from ATMEL Library.
FUNC void DDRAM_Setup (void) {
  if (Setup & 0x02) {
    _WDWORD(0xFFFFDF20,0x01020002);
    // Setup DDRAM Controller

    // 0xFFFFE600 DDR2C Base Address
    // Enable DDR2 clock x2 in PMC
    
    _WDWORD(0xFFFFFC00,0x04);    
    

    // Disable anticipated read
    _WDWORD(0xFFFFE82C,0x04 | _RDWORD(0xFFFFE82C));
     
    // -----------------------Step 1------------------- 
    // Program the memory device type
    // ------------------------------------------------ 
    
    // Configure the DDR controller
    // HDDRSDRC2_MDR, AT91C_DDRC2_DBW_16_BITS   |     // 16-bit DDR
    // AT91C_DDRC2_MD_DDR2_SDRAM       // DDR2
    _WDWORD(0xFFFFE820,0x16);
    
    // -----------------------Step 2------------------- 
    // 1. Program the features of DDR2-SDRAM device into 
    //    the Configuration Register.
    // 2. Program the features of DDR2-SDRAM device into 
    //    the Timing Register HDDRSDRC2_T0PR.    
    // 3. Program the features of DDR2-SDRAM device into 
    //    the Timing Register HDDRSDRC2_T1PR.
    // 4. Program the features of DDR2-SDRAM device into 
    //    the Timing Register HDDRSDRC2_T2PR.
    // ------------------------------------------------ 
    
    // HDDRSDRC2_CR, AT91C_DDRC2_NC_DDR10_SDR9  |     // 10 column bits (1K) 
    //          AT91C_DDRC2_NR_14          |          // 14 row bits    (8K) 
    //          AT91C_DDRC2_CAS_3          |          // CAS Latency 3
    //          AT91C_DDRC2_DLL_RESET_DISABLED        // DLL not reset
    _WDWORD(0xFFFFE808,0x1000B9); //0x3D
    
    // assume timings for 7.5ns min clock period
    // HDDRSDRC2_T0PR, AT91C_DDRC2_TRAS_6       |     //  6 * 7.5 = 45   ns
    //            AT91C_DDRC2_TRCD_2            |     //  2 * 7.5 = 15   ns
    //            AT91C_DDRC2_TWR_2             |     //  2 * 7.5 = 15   ns
    //            AT91C_DDRC2_TRC_8             |     //  8 * 7.5 = 60   ns
    //            AT91C_DDRC2_TRP_2             |     //  2 * 7.5 = 15   ns
    //            AT91C_DDRC2_TRRD_2            |     //  2 * 7.5 = 15   ns
    //            AT91C_DDRC2_TWTR_1            |     //  2 clock cycle
    //            AT91C_DDRC2_TMRD_2                  //  2 clock cycles
    _WDWORD(0xFFFFE80C,0x21228226);

    // HDDRSDRC2_T1PR, AT91C_DDRC2_TXP_2  |           //  2 * 7.5 = 15 ns
    //                 200 << 16          |           // 200 clock cycles, TXSRD: Exit self refresh delay to Read command
    //                 16 << 8            |           // 16 * 7.5 = 120 ns TXSNR: Exit self refresh delay to non read command
    //                 AT91C_DDRC2_TRFC_14 << 0       // 14 * 7.5 = 105 ns (must be 105 ns for 512Mb DDR)
    _WDWORD(0xFFFFE810,0x02C8100E);

    // HDDRSDRC2_T2PR, AT91C_DDRC2_TRTP_2   |         //  2 * 7.5 = 15 ns
    //                 AT91C_DDRC2_TRPA_0   |         //  0 * 7.5 = 0 ns
    //                 AT91C_DDRC2_TXARDS_7 |         //  7 clock cycles
    //                 AT91C_DDRC2_TXARD_2            //  2 clock cycles
    _WDWORD(0xFFFFE814,0x2072);
    
    // -----------------------Step 3------------------- 
    // An NOP command is issued to the DDR2-SDRAM to 
    // enable clock.
    // ------------------------------------------------ 

    _WDWORD(0xFFFFE800,0x1);
    _WDWORD(0x20000000,0x0);
    // A minimum pause of 200 ¦Ìs is provided to precede any signal toggle.
    _sleep_(2);
    // Now clocks which drive DDR2-SDRAM device are enabled
    
    // -----------------------Step 4------------------- 
    // An NOP command is issued to the DDR2-SDRAM 
    // ------------------------------------------------ 
    // HDDRSDRC2_MR, AT91C_DDRC2_MODE_NOP_CMD  
    _WDWORD(0xFFFFE800,0x1);
    _WDWORD(0x20000000,0x0);
    // wait 400 ns min
    _sleep_(1);
    // Now CKE is driven high.    
  
    // -----------------------Step 5------------------- 
    // An all banks precharge command is issued to the 
    // DDR2-SDRAM.
    // ------------------------------------------------ 
    // HDDRSDRC2_MR, AT91C_DDRC2_MODE_PRCGALL_CMD  
    _WDWORD(0xFFFFE800,0x2);
    _WDWORD(0x20000000,0x0);
    // wait 400 ns min
    _sleep_(1);

    // -----------------------Step 6------------------- 
    // An Extended Mode Register set (EMRS2) cycle is 
    // issued to chose between commercialor high 
    // temperature operations
    // ------------------------------------------------ 
   
    // HDDRSDRC2_MR, AT91C_DDRC2_MODE_EXT_LMR_CMD  
    _WDWORD(0xFFFFE800,0x5);
    //_WDWORD(0x24000000,0x0); // The write address must be chosen so that BA[1] is set to 1 and BA[0] are set to 0.
    _WDWORD(0x22000000,0x0); // The write address must be chosen so that BA[1] is set to 1 and BA[0] are set to 0.
    // wait 2 cycles min
    _sleep_(1);
    
    
    
    // -----------------------Step 7------------------- 
    // An Extended Mode Register set (EMRS3) cycle is 
    // issued to set all registers to 0.
    // ------------------------------------------------
    // HDDRSDRC2_MR, AT91C_DDRC2_MODE_EXT_LMR_CMD  
    _WDWORD(0xFFFFE800,0x5);
    //_WDWORD(0x26000000,0x0);
	_WDWORD(0x23000000,0x0);
    // wait 2 cycles min
    _sleep_(1);

    // -----------------------Step 8------------------- 
    // An Extended Mode Register set (EMRS1) cycle is 
    // issued to enable DLL.
    // ------------------------------------------------
    // HDDRSDRC2_MR, AT91C_DDRC2_MODE_EXT_LMR_CMD  
    _WDWORD(0xFFFFE800,0x5);
    //_WDWORD(0x22000000,0x0); // The write address must be chosen so that BA[1] and BA[0] are set to 0.
    _WDWORD(0x21000000,0x0); // The write address must be chosen so that BA[1] and BA[0] are set to 0.
    // An additional 200 cycles of clock are required for locking DLL
    _sleep_(2);

    // -----------------------Step 9------------------- 
    // Program DLL field into the Configuration Register.
    // -------------------------------------------------
    
    // HDDRSDRC2_CR, cr | AT91C_DDRC2_DLL_RESET_ENABLED
    _WDWORD(0xFFFFE808,0x80 | _RDWORD(0xFFFFE808));
    
    // -----------------------Step 10------------------- 
    // A Mode Register set (MRS) cycle is issued to reset
    // DLL.
    // -------------------------------------------------
    // HDDRSDRC2_MR, AT91C_DDRC2_MODE_LMR_CMD
     
    _WDWORD(0xFFFFE800,0x3);
    _WDWORD(0x20000000,0x0); // The write address must be chosen so that BA[1:0] bits are set to 0.
    // wait 2 cycles min
    _sleep_(1);
    
    // -----------------------Step 11------------------- 
    // An all banks precharge command is issued to the 
    // DDR2-SDRAM.
    // -------------------------------------------------
    // HDDRSDRC2_MR, AT91C_DDRC2_MODE_PRCGALL_CMD
    _WDWORD(0xFFFFE800,0x2);
    _WDWORD(0x20000000,0x0);  // Perform a write access to any DDR2-SDRAM address to acknowledge this command.
    // wait 2 cycles min
    _sleep_(1);

    // -----------------------Step 12------------------- 
    // Two auto-refresh (CBR) cycles are provided. 
    // Program the auto refresh command (CBR) into the 
    // Mode Register.
    // -------------------------------------------------
    // HDDRSDRC2_MR, AT91C_DDRC2_MODE_RFSH_CMD
    _WDWORD(0xFFFFE800,0x4);
    _WDWORD(0x20000000,0x0);  // Perform a write access to any DDR2-SDRAM address to acknowledge this command.
    // wait 2 cycles min
    _sleep_(1);
    // Set 2nd CBR
    _WDWORD(0xFFFFE800,0x4);
    _WDWORD(0x20000000,0x0);  // Perform a write access to any DDR2-SDRAM address to acknowledge this command.
    // wait 2 cycles min
    _sleep_(1);
  
    // -----------------------Step 13------------------- 
    // Program DLL field into the Configuration Register
    // to low(Disable DLL reset).
    // -------------------------------------------------
    // HDDRSDRC2_CR, cr & (~AT91C_DDRC2_DLL_RESET_ENABLED)  
    _WDWORD(0xFFFFE808,_RDWORD(0xFFFFE808) & 0xFFFFFF7F);

    // -----------------------Step 14------------------- 
    // A Mode Register set (MRS) cycle is issued to 
    // program the parameters of the DDR2-SDRAM devices
    // -------------------------------------------------
    // HDDRSDRC2_MR, AT91C_DDRC2_MODE_LMR_CMD
    _WDWORD(0xFFFFE800,0x3);
    _WDWORD(0x20000000,0x0); // The write address must be chosen so that BA[1:0] are set to 0.
    // wait 2 cycles min
    _sleep_(1);
    
    // -----------------------Step 15------------------- 
    // Program OCD field into the Configuration Register
    // to high (OCD calibration default)
    // -------------------------------------------------
    _WDWORD(0xFFFFE808,_RDWORD(0xFFFFE808) | (0x07 << 12));
    
    // -----------------------Step 16------------------- 
    // An Extended Mode Register set (EMRS1) cycle is 
    // issued to OCD default value.
    // -------------------------------------------------
    // HDDRSDRC2_MR, AT91C_DDRC2_MODE_EXT_LMR_CMD
    _WDWORD(0xFFFFE800,0x5);
    //_WDWORD(0x22000000,0x0); // The write address must be chosen so that BA[1] is set to 0 and BA[0] is set to 1.
	_WDWORD(0x21000000,0x0); // The write address must be chosen so that BA[1] is set to 0 and BA[0] is set to 1.
    // wait 2 cycles min
    _sleep_(1);

    // -----------------------Step 17------------------- 
    // Program OCD field into the Configuration Register 
    // to low (OCD calibration mode exit).
    // -------------------------------------------------
    _WDWORD(0xFFFFE808,_RDWORD(0xFFFFE808) & 0xFFFF8FFF);
    // wait 2 cycles min
    _sleep_(1);
    
    // -----------------------Step 18------------------- 
    // An Extended Mode Register set (EMRS1) cycle is 
    // issued to enable OCD exit.
    // -------------------------------------------------
    // HDDRSDRC2_MR, AT91C_DDRC2_MODE_EXT_LMR_CMD
    _WDWORD(0xFFFFE800,0x5);
    //_WDWORD(0x26000000,0x0); // The write address must be chosen so that BA[1] is set to 1 and BA[0] is set to 1.
    _WDWORD(0x21000000,0x0); // The write address must be chosen so that BA[1] is set to 1 and BA[0] is set to 1.
    // wait 2 cycles min
    _sleep_(1);
    
    
    // -----------------------Step 19,20------------------- 
    // A mode Normal command is provided. Program the 
    // Normal mode into Mode Register.
    // -------------------------------------------------
    // HDDRSDRC2_MR, AT91C_DDRC2_MODE_NORMAL_CMD
    _WDWORD(0xFFFFE800,0x0);
    _WDWORD(0x20000000,0x0);  // Perform a write access to any DDR2-SDRAM address.
     // wait 2 cycles min
    _sleep_(1);
    
    // -----------------------Step 21------------------- 
    // Write the refresh rate into the count field in the 
    // Refresh Timer register. The DDR2-SDRAM device requires a
    // refresh every 15.625 ¦Ìs or 7.81 ¦Ìs. With a 100 
    // MHz frequency, the refresh timer count register must to 
    // be set with (15.625 /100 MHz) = 1562 i.e. 0x061A or 
    // (7.81 /100MHz) = 781 i.e. 0x030d
    // -------------------------------------------------
    // HDDRSDRC2_RTR, 0x00000411
    _WDWORD(0xFFFFE804,0x00000411);
    
    // Read optimization" shall be un-selected on this revision.
    _WDWORD(0xFFFFE82C,0x04);
    
    // OK now we are ready to work on the DDRSDR

    // wait for end of calibration
    _sleep_(1);
  }
}

FUNC void Remap (void) {
  if (Setup & 0x10) {
    _WDWORD(MATRIX+0x100,0x00000003);   // MATRIX_MRCR: Remap IRAM to 0
  }
}

FUNC void PC_Setup (void) {
  if (Setup & 0x40) {
    PC = Entry;
  }
}

FUNC void GoMain (void) {
  if ((Setup & 0xA0) == 0xA0) {
    exec("g,main");
  }
}


// <o1.0> Clock Setup
// <o1.1> SDRAM Setup
// <e1.4> Remap
// </e>
// <e1.5> Download Program
FUNC void Download (void) {
  if (Setup & 0x20) {
//  <s0.80> Command for Loading
    exec("LOAD Output//Bootloader.axf INCREMENTAL");
  }
}
// </e>
// <e0.6> Setup Program Counter to Entry Point
//   <o1> Program Entry Point <0x0-0xFFFFFFFF>
// </e>
// <e.7> Execute Program untill Main Function
// </e>
Setup = 0xF1;
Entry = 0x00000000;


Clock_Setup();
DDRAM_Setup();
Remap();
Download();
PC_Setup();
//GoMain();
